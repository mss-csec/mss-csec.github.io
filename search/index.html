<!DOCTYPE html>
<html dir="ltr" lang="en">
<!-- head -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="theme-color" content="#f52f2f">

  <link rel="dns-prefetch" href="https://brick.a.ssl.fastly.net">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  <link rel="dns-prefetch" href="https://googletagmanager.com">

  <title>MSS CSEC • Markville's Computer Science Education Club
</title>

  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="MSS CSEC" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Markville’s Computer Science Education Club" />
<meta property="og:description" content="Markville’s Computer Science Education Club" />
<link rel="canonical" href="https://mss-csec.github.io/search/" />
<meta property="og:url" content="https://mss-csec.github.io/search/" />
<meta property="og:site_name" content="MSS CSEC" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"MSS CSEC","description":"Markville’s Computer Science Education Club","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://mss-csec.github.io/assets/images/favicons/icon-128.png"}},"url":"https://mss-csec.github.io/search/"}</script>
<!-- End Jekyll SEO tag -->


  
  <link rel="mask-icon" href="/assets/images/favicons/icon-pinned.svg?v=dd7c8e3" color="#f52f2f">
  <link id="favicon" rel="shortcut icon" href="/assets/images/favicons/icon.ico?v=dd7c8e3" type="image/x-icon">

  
  <!-- BEGIN GA -->
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-107141139-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>

  <!-- END GA -->
  

  <!-- BEGIN CSS -->
  <link href="https://brick.a.ssl.fastly.net/Lato:300,400,700,400i:f" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css" integrity="sha384-B41nY7vEWuDrE9Mr+J2nBL0Liu+nl/rBXTdpQal730oTHdlrlXHzYMOhDU60cwde" crossorigin="anonymous">

  
  

  <link href="/assets/lib/skeleton.css?v=dd7c8e3" rel="stylesheet" class="toggled-theme" data-alt-prop="href" data-alt-light="/assets/lib/skeleton.css?v=dd7c8e3" data-alt-dark="/assets/lib/skeleton-dark.css?v=dd7c8e3">

  

  <link href="/assets/css/main.css?v=dd7c8e3" rel="stylesheet" class="toggled-theme" data-alt-prop="href" data-alt-light="/assets/css/main.css?v=dd7c8e3" data-alt-dark="/assets/css/main-dark.css?v=dd7c8e3">

  <link href="/assets/lib/pygments-manni.css?v=dd7c8e3" rel="stylesheet" class="toggled-theme" data-alt-prop="href" data-alt-light="/assets/lib/pygments-manni.css?v=dd7c8e3" data-alt-dark="/assets/lib/pygments-native.css?v=dd7c8e3">

  
  

  
  <!-- END CSS -->

  <!-- BEGIN JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f" crossorigin="anonymous" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.1.4/js.cookie.min.js" integrity="sha384-3C51VYzyLN6W+IdxzwqCdGDQUOJfaRbPH2h6z97sB+sD4nZ4FCymhVZFvHMGN2ZE" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.0.0/anchor.min.js" integrity="sha384-vWR/JwZ17UvVCsqyfcCiaUK/5IAENMkGqXYrBRCURUFLS+aW63Zpsz5XqiDzrMQu" crossorigin="anonymous" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js" integrity="sha384-L9gv4ooDLrYwW0QCM6zY3EKSSPrsuUncpx26+erN0pJX4wv1B1FzVW1SvpcJPx/8" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js" integrity="sha384-RkgGHBDdR8eyBOoWeZ/vpGg1cOvSAJRflCUDACusAAIVwkwPrOUYykglPeqWakZu" crossorigin="anonymous" defer></script>

  <script src="/assets/js/main.js" defer></script>

  <script src="/assets/js/feedback.js" defer></script>

  
    
  <script src="/assets/lib/lunr.min.js" defer></script>
    
  <script src="/assets/js/search.js" defer></script>
    
  

  <!-- BEGIN PAGE-ADDED JS -->
  <script>
    window.SCRIPTS = (function (g) {
      var scripts = [];

      return {
        add: function (fn) {
          scripts.push(fn);
        },
        run: function () {
          for (var i=0;i<scripts.length;i++) {
            scripts[i].call(g);
          }
        }
      };
    })(window);
  </script>
  <!-- END PAGE-ADDED JS -->

  <!-- BEGIN MATHJAX -->
  <script type='text/x-mathjax-config'>
    MathJax.Hub.Config({
      extensions: [
        'tex2jax.js',
        'TeX/AMSmath.js',
        'TeX/AMSsymbols.js',
        'TeX/cancel.js',
        'TeX/color.js'
        
      ],
      jax: [
        'input/TeX',
        'output/CommonHTML'
        
      ],
      TeX: {
        equationNumbers: {
          autoNumber: 'AMS'
        }
      },
      tex2jax: {
        balanceBraces: false,
        processEnvironments: false,
        processRefs: false
        
      }
      
    });
  </script>
  <!-- END MATHJAX -->
  <!-- END JS -->

  <noscript><style>
  script[type*='math/tex']{display:inline-block!important;font-family:monospace;white-space:pre;}
  script[type*='math/tex'][type*='mode=display']{display:block!important;width:100%;text-align:center;}
  </style></noscript>
</head>

<body class="no-js no-hero">
  <!-- header -->
  


<p class="announcement-sticky" data-display-until="2017-10-06" data-id="/announcements/2017/09/welcome-to-the-new-csec-site">
  This site is currently in beta. <a href="/announcements/2017/09/welcome-to-the-new-csec-site/" class="read-more">Read more &raquo;</a> <a href="#" class="close-el">&times;</a>
</p>

<header class="site-header">
  <div class="container">
    <a class="logo main-logo" aria-label="{csec}" href="/">
      <svg xmlns="http://www.w3.org/2000/svg" width="116" height="40" onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
        <defs>
          <mask id="m"><path d="M12.82 36q-3.06 0-4.96-.6-1.89-.61-2.82-2.14-.89-1.52-.77-4.29l.16-4.02q0-2.54-.89-3.5-.88-1.01-2.73-1.01H0v-2.25h.77q1.9 0 2.82-1.01.93-1.04.93-3.29l-.08-2.9Q4.44 4 11.78 4h2.54v2.29h-3.3q-3.75 0-3.75 4.26l.08 2.82q0 4.42-3.51 5.95 3.43 1.13 3.43 6.23l-.12 3.38q0 2.7 1.17 3.74 1.17 1.09 3.91 1.09h2.06V36zm16.7-5.95q-2.66 0-4.76-1.25-2.1-1.25-3.3-3.42-1.17-2.21-1.17-4.94 0-2.74 1.17-4.9 1.21-2.17 3.3-3.42 2.1-1.25 4.72-1.25 2.22 0 4.03.93 1.82.89 2.94 2.5l-1.82 1.77-.28.28-.2-.2q0-.36-.16-.64-.12-.32-.61-.72-.85-.76-1.86-1.09-1.01-.36-2.38-.36-1.58 0-2.94.89-1.33.85-2.14 2.42-.81 1.57-.81 3.62t.81 3.7q.85 1.65 2.3 2.58 1.5.93 3.3.93 2.78 0 4.8-2.25l1.7 1.97q-2.7 2.9-6.66 2.9zm18.8-.04q-4.68 0-7.82-2.9l1.62-2.74.24-.36.24.16q0 .08.04.36.08.28.24.56.16.28.44.56.93.93 2.1 1.45 1.21.48 2.98.48 2.18 0 3.43-.76 1.25-.81 1.25-2.17 0-1.17-1.01-1.93t-3.63-1.61q-6.94-1.97-6.94-5.71 0-2.13 1.74-3.38 1.78-1.25 5.04-1.25 2.5 0 4.19.72 1.74.68 3.14 2.17l-1.66 2.01-.28.32-.2-.2q-.04-.44-.2-.72-.12-.28-.57-.64-.93-.72-2.1-1.09-1.13-.4-2.26-.4-1.74 0-2.86.6-1.09.6-1.09 1.69 0 1.01 1.13 1.85 1.13.85 4.07 1.69 3.47 1.05 4.88 2.29 1.46 1.21 1.46 3.18 0 2.5-1.98 4.14-1.94 1.61-5.65 1.61zm21.02 0q-4.11 0-6.58-2.5-2.42-2.5-2.42-7.03 0-3.02 1.13-5.18 1.13-2.21 3.02-3.34 1.94-1.17 4.31-1.17 3.34 0 5.41 2.21 2.1 2.21 2.1 6.51 0 .44-.08 1.33h-13.1q.16 3.38 1.9 5.1 1.74 1.73 4.4 1.73 2.9 0 4.76-2.05l1.62 1.57q-2.34 2.82-6.46 2.82zm4.03-11.42q0-2.58-1.33-4.06Q70.75 13 68.61 13q-2.02 0-3.51 1.41-1.5 1.41-1.86 4.18zm16.66 11.46q-2.66 0-4.76-1.25-2.1-1.25-3.3-3.42-1.17-2.21-1.17-4.94 0-2.74 1.17-4.9 1.21-2.17 3.3-3.42 2.1-1.25 4.72-1.25 2.22 0 4.03.93 1.82.89 2.94 2.5l-1.82 1.77-.28.28-.2-.2q0-.36-.16-.64-.12-.32-.61-.72-.85-.76-1.86-1.09-1.01-.36-2.38-.36-1.58 0-2.94.89-1.33.85-2.14 2.42-.81 1.57-.81 3.62t.81 3.7q.85 1.65 2.3 2.58 1.5.93 3.3.93 2.78 0 4.8-2.25l1.7 1.97q-2.7 2.9-6.66 2.9zM100.92 36v-2.25h2.06q2.74 0 3.91-1.09 1.17-1.05 1.17-3.74l-.12-3.38q0-5.1 3.43-6.23-3.51-1.53-3.51-5.95l.08-2.82q0-4.26-3.75-4.26h-3.31V4h2.54q7.34 0 7.34 6.99l-.08 2.9q0 2.25.93 3.3.93 1.01 2.82 1.01h.76v2.25h-.81q-1.86 0-2.74 1.01-.89.97-.89 3.5l.16 4.02q.12 2.78-.81 4.3-.89 1.53-2.78 2.13-1.9.6-4.96.6z" fill="#fff" /></mask>
        <!-- Give each of the six letters a unique colour -->
        <!-- <linearGradient id="grad">
          <stop offset="0%" stop-color="#f52f2f" />
          <stop offset="17%" stop-color="#f52f2f" />
          <stop offset="17%" stop-color="orange" />
          <stop offset="33%" stop-color="orange" />
          <stop offset="33%" stop-color="gold" />
          <stop offset="50%" stop-color="gold" />
          <stop offset="50%" stop-color="green" />
          <stop offset="67%" stop-color="green" />
          <stop offset="67%" stop-color="blue" />
          <stop offset="83%" stop-color="blue" />
          <stop offset="83%" stop-color="purple" />
          <stop offset="100%" stop-color="purple" />
        </linearGradient> -->
        </defs>
        <rect class="main-logo-background" width="144" height="40" mask="url(#m)" fill="#f52f2f"></rect>
      </svg>
      <img class="svg-fallback" src="/assets/images/logo.png" style="display:none">
    </a>

    <input type="checkbox" class="responsive-menu-toggler" id="toggle-menu">
    <label for="toggle-menu"><a ontouchstart="">menu</a></label>
    <div class="responsive-menu-items">
      <div class="menu">
        <a class="menu-header" href="/subclubs/">Subclubs</a>

        <dl class="menu-items">
          
          
            
            
          <dt><a href="/subclubs/beginners/">Beginners'</a></dt>
          
            
            
          <dt><a href="/subclubs/advanced/">Advanced</a></dt>
          
          
        </dl>
      </div>

      <div class="menu">
        <a class="menu-header" href="/resources/">Resources</a>

        <dl class="menu-items">
          <dt class="menu-items-more"><a href="/resources/">All resources</a></dt>
        </dl>
      </div>

      <div class="search-box">
        <form action="/search" id="search-form" method="get">
          <input type="search" id="search" name="q" placeholder="Search...">
        </form>
      </div>

      <div class="options">
        <a class="icon" tabindex="0">
          <span class="circle"></span>
          <span class="circle"></span>
          <span class="circle"></span>
        </a>
        <div class="content">
          <label>
            <input type="checkbox" id="toggle-dark-theme">
            Dark theme
          </label>
        </div>
      </div>
    </div>
  </div>
</header>

  <main>
    <div class="content container">
  <h4 style="margin-top:100px">Search results for <em id="search-query"></em> :</h4>

  <div id="search-results">
    <h3 class="disabled">Searching...</h3>
  </div>
</div>

<script>
searchStore={subclubs:{ "lessons-advanced-setting-things-up":{ url:"/lessons/advanced/setting-things-up",title:"Setting Things Up",subclub:"advanced",content:"\n\n\nThere are a few things which we will be using often in this course; it is imperative that you have had them set up when we use them.\n\n\nPlease ensure that the following are ready to use by the first lesson:\n\n\n\n\nAn IDE and compiler for your language of choice\n\n\nA wcipeg account, for challenging practice\n\n\n\n\nThe latter point is rather trivial; the rest of this \"lesson\" regards the setup of an IDE for C++.\n\n\n\n\nAn IDE for C++\n\n\nCode::Blocks is a nice, minimalistic cross-platform IDE for C++. It is very useful for small programs&#8201;&#8212;&#8201;contest submissions&#8201;&#8212;&#8201;and, with some extra work, will support large projects.\n\n\nIt can be downloaded here.\n\n\n\n\n\nNote\n\n\n\nThe Mac/OS-X version of Code::Blocks is outdated.\n\n\nYou may wish to use a C++ Shell instead.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere are six download links for the Windows version of Code::Blocks.\n\n\nMake sure that you are downloading a 16.01mingw version, as those include the GCC Compiler!\n\n\n\n\n\n\nUsing Code::Blocks\n\nIf you are running Code::Blocks on Mac OS-X, you may be urged to download a command line. Allow Code::Blocks to install the command line.\n\n\nTest that Code::Blocks is working by creating a new C++ file selecting File -&gt; New -&gt; Empty file, or with Ctrl+Shift+N. Save this file with File -&gt; Save or with Ctrl+S with the file extension .cpp.\n\n\n\n\n\nImportant\n\n\nFiles will normally save as a C Source file with the .c extension. However, we are working in C++; your file must use the .cpp extension, or it will not be compiled as a C++ Source!\n\n\n\n\n\nCopy and paste the following code into your empty file:\n\n\nhelloworld.cpp\n\n1\n2\n3\n4\n5\n6\n7\n#include &lt;iostream&gt;\n\nint main(int argc, const char* argv[])\n{\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    return 0;\n}\n\nIn a toolbar at the top of your screen, you will see a button which looks like a green triangle (Run) next to a button which looks like a yellow gear (Compile). Next to those two buttons is a button with both. This is the Compile and Run button; click on it, and wait for your program to compile and run.\n\n\nIf this is the first time you&#8217;re using Code::Blocks, it should fail. On the menu bar, select Settings -&gt; compiler&#8230;&#8203; and a little screen should pop up.\n\n\nOn the Global compiler settings tab, choose the GNU GCC Compiler for the Selected compiler, and then click on Reset defaults at the right.\n\n\nAfter that, try compiling and running your program again. A black window should pop out with the text Hello World!, and you are now ready to continue.\n\n\nDoesn&#8217;t work? Google is your friend! Welcome to Computer Science.\n\n\n\n" },"lessons-advanced-introduction-to-cpp":{ url:"/lessons/advanced/introduction-to-cpp",title:"Introduction to C++",subclub:"advanced",content:"\n\n\nThe Advanced Course begins with the assumption that you are familiar and comfortable with programming so that we can advance to more complex, more difficult, more interesting topics.\n\n\n\n\n\nImportant\n\n\n\nThis course assumes you are familiar with every concept in this lesson, perhaps with the sole exception of Object Oriented Programming.\n\n\nIf you are unable to solve problems such as CCC16S2: Tandem Bicycle, then it would probably be wise to take the Beginners' course instead.\n\n\n\n\n\n\nThe purpose of this lesson is to familiarize you with (or to provide you a review of) C++ syntax, which is this course&#8217;s language of choice.\n\n\nTable of Contents\n\nComments\nInput and Output\n\nOutput Using std::cout\nInput Using std::cin\n\n\nVariables and Types\n\nOperations on Primitives\nArrays\n\n\nLoops\nStrings\nModularity\n\nFunctions\nstructs\nPrototype declarations\n\n\n\n\n\n\n\nComments\n\n\nIn C++, single-line comments are denoted with //.\nAll text on the line of the double-slash, after the double-slash, is commented and won&#8217;t be parsed by the compiler.\nCode::Blocks will colour them grey by default.\nIn other environments, they are commonly coloured green.\n\n1\n2\n3\n4\n5\n// This is a single-line comment.\n\nint n; // This is also a single-line comment,\n       // but what came before the double-slashes\n       // will still be parsed by the compiler.\n\nSometimes, very long or very short explanations may be warranted.\nThe beginning of a comment block is denoted by /* and the ending by \\*/.\nThis allows us to put a comment in the middle of a line&#8201;&#8212;&#8201;or across multiple lines without needing to double-slash every line.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n/* This is the beginning of a comment block.\n * It's standard convention to put an asterick\n * in front of all lines contained in a comment\n * block.\n   But it isn't necessary.\n * It's also standard convention to not end the\n * block at the end of a line, but at the beginning\n * of a new line.\n */\n\nint /* We're putting this here as an example;\ndon't actually do this with simple statements.*/ n;\n\nComments are used to document code; when we show code to you, you will see many comments explaining exactly what each line does.\nWe would also appreciate it if, when you show us code to debug, you also include comments explaining what you intend each line to do.\n\n\n\n\nInput and Output\n\n\nC++ is a derivative of C, and both languages have their own library for I/O.\nBoth methods work; the C++ version is simpler (for now), but we&#8217;ll introduce the C version later.\n\n\nThe C++ I/O library is in the &lt;iostream&gt; header and resides in the std (Standard Library) namespace.\n\n\nOutput Using std::cout\n\nTo write (or print), we use the std::cout \"function\"with the &lt;&lt; operator:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n#include &lt;iostream&gt;  //for std::cout, std::endl\n\nusing namespace std; //so we don't have to write the std::\n\nint main(int argc, const char* argv[])\n{\n    //print Hello World!, a newline, and flush the stream\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n    return 0;\n}\n\nIn line 8, we print Hello World! with STL&#8217;s std::cout.\nSo that the code would execute, we encompassed the code inside the main function (line 5).\nSo that our compiler knows what cout and endl are, we first included &lt;iostream&gt; (line 1) and then told the compiler to allow us to freely use things from the std namespace (line 3).\n\n\n\n\n\nNote\n\n\n\nIt&#8217;s generally considered bad form to use using namespace std;, as it locks up many symbols (variable, class, function names) from use.\nAs such, these lessons (except for this section) will not use using namespace std;, instead opting to write the full symbols.\n\n\nYou may choose whether or not to use this line; it really doesn&#8217;t matter in your own code.\n\n\n\n\n\n\nAll of that is to say that, for now, we simply need those three lines to run any code.\nThe real meat of the matter here is line 8:\n\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n\nIf you&#8217;ve never used C++ before, this line looks pathological.\nDid I not just say that std::cout is a function?\nWhat&#8217;s with the double angle brackets?\n\n\nThis is a very interesting peculiarity with C++; for some reason&#8201;&#8212;&#8201;perhaps to appear more&#8230;&#8203; beginner friendly?&#8201;&#8212;&#8201;the &lt;iostream&gt; library really likes treating everything visually as a stream.\nThe double angle brackets are like the direction of the stream: in this case, towards std::cout (which stands for, by the way, Console Output).\nThis becomes more clear when you begin to look at reading from the console.\n\n\n\n\n\nNote\n\n\n\nstd::endl is not just a newline character.\nTo simply print a newline character, you can use '\\n'; std::endl generally prints both the newline character and the carriage return character ('\\r'), and then flushes the stream.\n\n\nWhen printing to the console, what is intended to print is first stored in a buffer.\nIt doesn&#8217;t print until it decides it needs to; on a typical console line, that&#8217;s during a screen refresh (sixty times a second).\nHowever, if you&#8217;re interacting with another program (like in practice problems), that&#8217;s rather slow; instead, you can flush it to have it printed immediately.\nstd::endl provides this functionality; you can also use std::flush or a program termination to print your output immediately.\n\n\n\n\n\n\nAnd, uhh, no&#8230;&#8203; std::cout is not actually a function; it&#8217;s an object.\nWe&#8217;ll just stop here.\n\n\n\nInput Using std::cin\n\nTo read (or scan), we use the std::cin \"function\" and the operator &gt;&gt;.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n#include &lt;stdio.h&gt;   //for std::cin and std::cout\n\nusing namespace std; //for dropping the std::\n\nint main(int argc, const char* argv[])\n{\n    int n;             //declare an integer n\n    cin &gt;&gt; n;          //read an integer from the console, putting it in n\n    cout &lt;&lt; n &lt;&lt; endl; //spit n back out, then a newline and flush the stream.\n    return 0;\n}\n\nLike with the pathological syntax of std::cout, the syntax of std::cin resembles that of a flow equation: something goes from std::cin to n.\n\n\n\n\n\nVariables and Types\n\n\nIn C++, variables are declared by writing [type] [variable name].\nYou can initialize them at declaration with [type] [variable name] = [value].\n\n\n\n\n\nNote\n\n\n\nMany languages offer automatic null-initialization; for example, an int would automatically start as 0.\nC is a low-level language (it&#8217;s closer to the hardware), and providing automatic null-initialization would be wasteful, as a variable can be declared and then subsequently initialized.\nWith null-initialization, there would be two writes: one with 0 and the next with the desired value; without, just one.\n\n\nSince C++ doesn&#8217;t provide null initialization, you must remember to initialize variables you intend to use.\nVariable declaration only allocates memory; initially, its values would simply be whatever was there before.\nFor your purposes, it&#8217;s nothing but garbage.\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n#include &lt;iostream&gt;\n\nint main(int argc, const char* argv[])\n{\n    int n;                  //declare an int called n\n    char c = 'A';           //declare a character called c and assign it the value of 'A'\n    double d = 0.0, e;      //declare a double called d and assign it 0.0; then declare a double called e\n\n    //spit out the values of the declared variables\n    std::cout &lt;&lt; n &lt;&lt; std::endl &lt;&lt; c &lt;&lt; std::endl &lt;&lt; d &lt;&lt; std::endl &lt;&lt; e &lt;&lt; std::endl;\n    return 0;\n}\n\nIf you run this code, you should see an output like the following:\n\n\n\n50786312\nA\n0.00000\n-2.46962e-185\n\n\n\nYou may notice that the output differs on lines 1 and 4; that&#8217;s because the program was outputting garbage that varies from machine to machine, from program to program, and from time to time.\n\n\nYou can declare two variables on the same statement like in line seven.\nEach variable is initialized separately.\n\n\nIn C++, there are four primitive types:\n\n\n\n\nthe int, an integral type which supports integers from -2,147,483,648 to 2,147,483,647,\n\n\nthe float, a floating-point type which supports six decimal digits of precision,\n\n\nthe char, a single-byte type which supports the default 128 ASCII characters, and\n\n\nthe bool, a boolean type which supports the boolean values true (1) and false(2).\n\n\n\n\n\n\n\nNote\n\n\n\nYou may be more familiar with the double primitive type, which is the double-precision floating-point type; if you ever find yourself really in need of using floating points, the double is most likely a better choice than the float.\n\n\nThe double supports fifteen decimal digits of precision.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn general, try to avoid using floating-point types, especially if your calculations include addition and subtraction.\nIf you must use floating points, try to restrict them to multiplication and division.\n\n\nYou can see why this is the case if you try to test if 0.1 + 0.2 == 0.3, or if 1.0 / 0.0 == 1.0 / -0.0.\nIn the former case, there&#8217;s not enough precision and the addition results in an extra little \\(4\\times10^{-17}\\); in the latter, 1.0 / 0.0 should result #INF and 1.0 / -0.0 should result -#INF, even though 0.0 and -0.0 are both mathematically and computationally equivalent.\n\n\n\n\n\n\nOperations on Primitives\n\nThere are six base operations, five compound operations, and four abbreviated operations that can be applied to primitive types:\n\n\n\n\nassignment: a = b sets the value of a to the value of b (whether b is a constant or variable), and returns the new value of a. You can assign smaller types to larger types, like if a was an int and b was a char.\n\n\naddition: a + b returns the sum of a and b; the return type is the largest type in the operation (in the order of double, int, char). ints and chars can overflow&#8201;&#8212;&#8201;if the result if over the capacity of the type, it will wrap around. Floating-point overflows result #INF.\n\n\nsubtraction: a - b returns the difference of b from a; the return type and overflow behaviour is the same as with addition.\n\n\nmultiplication: a * b retursn the product of a and  b. The return type and overflow behaviour is the same as with addition.\n\n\ndivision: a / b returns the quotient of a divided by b. If both a and b are integral types, the return type is also integral and the result is truncated (round towards zero). If either is a floating-point type, the result will be floating-point. Integer division by zero will immediately crash a program. Floating-point division by zero results &pm;INF depending on the signs of the divisor and the zero and #IND if the numerator is also zero.\n\n\nmodulus: a % b returns the modulus, or remainder, of a divided by b. The modulus is only valid across integral types, and anything modulo zero will immediately crash the program. Typically, the result of a modulus has the same sign as the divisor.\n\n\n\n\nThe five compound operations do both an operation and an assignment:\n\n    n += m; //equivalent to n = n + m;\n    n -= m; //equivalent to n = n - m;\n    n *= m; //equivalent to n = n * m;\n    n /= m; //equivalent to n = n / m;\n    n %= m; //equivalent to n = n % m;\n    n ++;   //equivalent to n = n + 1;, but returns the original value of n.\n    ++ n;   //equivalent to n = n + 1;\n    n --;   //equivalent to n = n - 1;, but returns the original value of n.\n    -- n;   //equivalent to n = n - 1;\n\nSince operations can both assign and return a value, you can do things like this:\n\n    std::cout &lt;&lt; 3 + (n = m + (l *= 2));\n    // assigns l to 2l, n to m + 2l, and prints 3 + m + 2l\n\nBoolean Operations and Branching\n\nBranching is an important part of any program. In C++, this is accomplished using the if and switch statements:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n    if (n &gt; 10) //for n is some int\n    {\n        std::cout &lt;&lt; \"n is greater than 10.\" &lt;&lt; std::endl;\n    }\n    else if (n &lt; 10)\n    {\n        std::cout &lt;&lt; \"n is less than 10.\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"n is 10.\" &lt;&lt; std::endl;\n    }\n\n    switch (c) //for c is some char\n    {\n        case 'Z':\n            std::cout &lt;&lt; \"Z, the last letter of the alphabet\" &lt;&lt; std::endl;\n            break; //ends the branch\n        case 'Y':\n            std::cout &lt;&lt; \"Y, a consonant, but also \";\n            //because there's no break statement, the 'Y' case leaks\n            //into the next cases.\n        case 'A':\n        case 'E': //you can chain cases that should\n        case 'I': //result in the same behavior.\n        case 'O':\n        case 'U':\n            std::cout &lt;&lt; c &lt;&lt; \", a vowel.\" &lt;&lt; std::endl;\n            break;\n        default:\n            std::cout &lt;&lt; \"fatal error, terminating program\" &lt;&lt; std::endl;\n            c = 1/0;\n            break;\n    }\n\nWhile if statements take boolean values, switch statements take a variable and check cases against constant, compiler-time-deterministic values.\n\n\n\n\n\nNote\n\n\n\nSince if statements directly take boolean variables, if you have a boolean variable you wish to check, you can directly put it into the statement:\n\n    bool b = true;\n    if (b)\n    {\n        std::cout &lt;&lt; \"asdf\";\n    }\n\nwill always write asdf, barring extreme circumstances.\n\n\n\n\n\n\nTo use other primitive types with if statements (or more generally, conditional statements), you can use various boolean operators:\n\n\n\n\nequivalence: a == b returns true if a and b have exactly the same value, bit-by-bit (with the exception that 0.0 and -0.0 are equivalent). Otherwise, it returns false.\n\n\nnot equal to: a != b returns true if a is not equivalent to b. Otherwise, it returns false. Commonly, this is called the \"bang equals\". This operator is also equivalent to an exclusive or on boolean values.\n\n\nstrict less than: a &lt; b returns true if a is less than, and not equal to, b. Otherwise, it returns false.\n\n\nstrict greater than: a &gt; b returns true if a is greater than, and not equal to, b. Otherwise, it returns false.\n\n\nless than or equal to: a &lt;= b returns true if a is less than or equal to b. Otherwise, it returns false.\n\n\ngreater than or equal to: a &gt;= b returns true if a is greater than or equal to b. Otherwise, it returns false.\n\n\nlogical negation: !a returns true if a is false and vice-versa. This operator is commonly called the \"bang,\" and is also known as the \"logical NOT.\"\n\n\nlogical AND: a &amp;&amp; b returns true if both a and b are true, and otherwise false. Evaluation is always left-to-right; if a is false, then b will not be evaluated.\n\n\nlogical OR: a || b returns true if either a or b are true, and otherwise false. Evaluation is always left-to-right; if a is true, then b will not be evaluated.\n\n\nternary operator: a ? b : c returns b if a is true, and c if a is false. This is a powerful operator that allows for interesting shortcuts in code; typically, they make code harder to read, but easier to write. Interestingly, despite being defined similarly, they don&#8217;t behave similarly to if statements; they are, on average, 60% faster.\n\n\n\n\n\n\n\nImportant\n\n\n\nWhen checking for equivalence, ensure that you use the double equal operator, or you will be assigning values and using the assigned value!\nif (n = 0) will never fire, and if (n = 1) will always fire because the assigned values will always be used in the check!\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause the logical AND and logical OR will ignore their second operand if the result can be determined directly from the first, compound expressions can be dangerous. true || (++n &gt; 10) will never increment n.\n\n\nHowever, they can also be useful when checking things that may explode in your face without extra checks:\nd != 0 &amp;&amp; n / d &gt; 3\nwill never explode your program due to a divide-by-zero, as if d were zero then n / d would never evaluate.\n\n\n\n\n\n\n\n\nArrays\n\nIn C++, an array is a modifier on a type. They&#8217;re declared by adding [] at the end of variable name, initialized with {}, and accessed with [].\n\n1\n2\n3\n    int n, arr[10];\n    double darr[] = {3.0, 3.1, 3.14, 3.141, 3.1415, 3.14159};\n    int arr_null_init[100] = {1};\n\nLine 1 declares an int, n, and an array of 10 ints, arr.\nBoth are filled with garbage.\n\n\nLine 2 declares an array of six doubles, initialized to pi at various precisions.\nLine 3 declares an array of a hundred ints, all initizalized to zero except position 0, which is initialized to 1.\n\n\nIn C++, arrays are zero-indexed:\n\n1\n2\n    int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    std::cout &lt;&lt; arr[0] &lt;&lt; arr[9] &lt;&lt; arr[10];\n\nThis snippet of code will output 09 and then some garbage (there are no spaces as we didn&#8217;t specify any), since the 10th index is after the end of the array.\n\n\nVariable-size Arrays: std::vector\n\nIf you need an array type but don&#8217;t know how many elements you need, you can use an std::vector from &lt;vector&gt;.\nstd::vectors begin with zero size and zero capacity, but increase as you add more elements with std::vector&lt;T&gt;::push_back(T), create more elements with std::vector&lt;T&gt;::emplace_back(T()), or reserve space for elements with std::vector&lt;T&gt;::reserve(int)``.\nThe increase in size and capacity is done automatically when needed.\n\n\nElements can also be removed off the back with std::vector&lt;T&gt;::pop_back().\n\n\nWhen declaring vectors, a type must be specified in angle brackets.\nSince they are not primitive types, vectors are automatically initialized.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, const char* argv[])\n{\n    std::vector&lt;int&gt; arr;   //no need to set initializations! In fact, they'll give you errors.\n    int size, in = 0;\n\n    std::cin &gt;&gt; size;\n\n    arr.reserve(size)\n\n    while(in &gt;= 0)         //leave when you get a negative input\n    {\n\tarr.push_back(in); //will automatically add directly to the end of the vector\n        std::cin &gt;&gt; in;\n    }\n\n    //spit everything back out\n    for (int i = 1; i &lt; arr.size(); ++i)\n    {\n        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\nLoops\n\n\nWhen dealing with arrays or anything which requires immediate repetition, we use loops. (Of course, you know this already.)\n\n\nIn C++, there are three primitive loops: the for loop, the while loop, and the do .. while loop.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int arr_size = 10;\n\n    ...\n\n    //there are three statements in the declaration of a for-loop:\n    // - the initializer, which is run as soon as scope enters the loop,\n    // - the condition, which is run before each iteration, and\n    // - the increment, which is run after each iteration.\n    for (int i = 0; i &lt; arr_size; ++i)\n    {\n        std::cout &lt;&lt; arr[i];\n    }\n    std::cout &lt;&lt; std::endl;\n\n    //the while loop is simpler; it's like an if-statement but every\n    //time we're about to leave the scope of the loop it goes back to\n    //the condition.\n    int i = 0;\n    while (i &lt; arr_size)\n    {\n        std::cout &lt;&lt; arr[i];\n        ++i;\n    }\n\n    //the do..while loop is like the while loop, except the first\n    //iteration will always run.\n    i = 0;\n    do\n    {\n        std::cout &lt;&lt; arr[i];\n        ++i;\n    } while (i &lt; arr_size);\n\n\n\n\nNote\n\n\n\nAll three loops do not necessarily need to have statements.\n\n\nThe for loop can be written as for(;;), and it will run as an infinite loop.\nThe while and do..while loops can be written as while(1) and they will also run as infinite loops.\n\n\n\n\n\n\nSometimes, you need to be able to control the actions of loops while inside it, usually when checking for edge cases.\nIn these cases, you can use the break and continue keywords:\n\n\n\n\nbreak immediately exits the innermost loop, and\n\n\ncontinue immediately exits the current iteration of the innermost loop. In a for loop, this counts and the end of an iteration, and the increment and condition statements will be immediately evaluated.\n\n\n\n\n\n\nStrings\n\n\nC is a low-level language, and supports the char* or char[] type as a string.\nIn C, string manipulation is usually done through the &lt;string.h&gt; library.\nC++ introduces the &lt;string&gt; library to make string manipulation a little less horrible.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    char cstr[1024] = \"This is a C-style string.\";\n    strcpy(cstr+8, \"C-style string manipulation.\");\n    strcat(cstr, \" This is the most accurate version of string manipulation, \");\n    strcat(cstr, \"but is a pain to do when you're new to the language.\");\n    std::cout &lt;&lt; cstr &lt;&lt; std::endl;\n\n    std::string str(\"This is a C++ STL string.\");\n    str = str.substr(0, 8) + \"manipulation of\" + str.substr(7, std::string::npos);\n    str += \" It's a lot easier to grasp, but it's certainly not as fast\";\n    str += \" computationally, if you know how to do C-string manipulation.\";\n    std::cout &lt;&lt; str &lt;&lt; std::endl;\n\n    return 0;\n}  \n\nThe reference is very useful when dealing with strings.\n\n\n\n\n\nNote\n\n\n\nC-strings are pointer-based and manipulation is heavy on the use of pointers.\nIf you aren&#8217;t comfortable with pointers, you should probably stick to STL strings.\n\n\n\n\n\n\n\n\nModularity\n\n\nFunctions\n\nIn C/C++, there isn&#8217;t really a big difference between methods/procedures and functions: they&#8217;re all declared the same way and behave pretty much the same way.\nMethods/procedures just have return type void; that is to say, it doesn&#8217;t return anything and so they can&#8217;t be used in expressions.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n#include &lt;iostream&gt;\n\n//return type, name, params\nint add(int a, int b)\n{\n    //code goes here (in this case, it's unnecessary).\n    //if the return type is not void, you must return a value\n    //in every possible branch.\n    return a + b;\n}\n\n//return type, name, params; in this case, this is a method\n//so it returns void\nvoid print(int n)\n{\n    std::cout &lt;&lt; n &lt;&lt; std::endl;\n\n    //in methods, returning is optional, but you can choose to return\n    //down certain branches to terminate early.\n    return;\n}\n\n//main can also return void in certain environments, and typically the\n//parameters are unnecessary. It's good form to include them, though.\nint main(int argc, const char* argv[])\n{\n    print(add(2,3));\n\n    //the main function actually doesn't need to return, but it's good form.\n    return 0;\n}\n\n\nstructs\n\nIn C++ there are classes you can use, but they&#8217;re designed specifically for OOP and are sometimes rather finicky to work with.\nstructs were made for C, and so they&#8217;re somewhat easier to work with, since they&#8217;re just wrappers for groups of data.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include &lt;iostream&gt;\n\nstruct whatever\n{\n    int a, b;     //member variables\n    void print(); //member function prototype\n}; //this semicolon is important!\n\n// this is how you define a member function outside its parent's declaration:\n// you need the scope resolution operator (::). You can also directly define\n// it inside its parent, but it's better form to do it outside as there's\n// less clutter when you're checking what you can do with a struct.\nvoid whatever::print()\n{\n    std::cout &lt;&lt; a + b &lt;&lt; std::endl;\n}\n\nint main()\n{\n    whatever w;\n    w.a = 5;\n    w.b = 895623;\n    w.print();\n\n    return 0;\n}\n\n\nPrototype declarations\n\nSometimes you will need to reference two functions or types within each other.\nC++ compilers parse from the top of the document to the bottom, so if a symbol isn&#8217;t yet declared it will start screaming at you even if it&#8217;s declared later.\nWhat you can do is make a prototype declaration to tell the compiler, \"Hey, here&#8217;s something I&#8217;m going to use before I define,\" and it won&#8217;t flip out.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nint recursion_a();\nint recursion_b()\n{\n    recursion_a();\n}\nint recursion_a()\n{\n    recursion_b();\n}\n\n\n" },"lessons-advanced-type-modifiers-and-pointers":{ url:"/lessons/advanced/type-modifiers-and-pointers",title:"Type Modifiers and Pointers",subclub:"advanced",content:"\n\n\nYou were probably taught that \"variables hold a value,\" and that \"different types hold different types of values.\"\n\n\nThe first statement is correct, but doesn&#8217;t show the full picture of what a variable is.\nThe second statement is wrong.\n\n\n\n\nWhat is a variable?\n\n\nIn programming, a variable refers to a segment of memory which is to be read from or written to during calculations.\n\n\nThis segment of memory has a specific length. Standard ints today are four bytes long. Since a bit can only store a certain amount of information, and bytes are collections of eight bits, there is only so much information that a four-byte int can hold.\n\n\nSpecifically, one of the thirty-two bits must be used to hold the sign of the number.\nThe rest thirty-one are used to indicate the magnitude of the number.\nAs such, a thirty-two bit int (or int32) can store integers between, inclusive, \\(-2,147,483,648\\) and \\(2,147,483,647\\).\n\n\nA type does not refer to the type of value that is stored, but rather the type of value that should be interpreted from the stored data.\nA float, for example, which stores the value of \\(\\sqrt{2}\\) to its highest precision, will be interpreted as something like \\(1.414214\\). However, if you interpret its data as an int, then you&#8217;ll get \\(1,068,827,891\\).\n\n\nIt&#8217;s kind of like words across different languages.\nIn English, \"die\" means to cease living.\nIn Dutch, \"die\" means this one.\nThey&#8217;re denoted&#8201;&#8212;&#8201;stored&#8201;&#8212;&#8201;the same way, but the interpretation is different, which leads to unfortunate misunderstandings like this:\n\n\n\n\n\nVariables in Memory\n\n\nIn programming, a variable refers to a segment of memory which is to be read from or written to during calculations.\n\n\n&#8212; Me, in like the first paragraph\n\n\n\nVariables are put into segments of memory.\nSo what&#8217;s memory?\n\n\nI&#8217;m sure you&#8217;re familiar with what RAM sticks are: they&#8217;re your \"working memory\" while your computer runs.\nEach stick of RAM is delimited into little chunks of eight bits called bytes.\nSo that we can find these bytes, each and every one of them has an address.\n\n\nYou can think of working memory as a giant warehouse.\n\n\n\n\n\nIn each little shelf is a small sheet of paper, holding an eight-bit binary number (or, if you wish, a number between 0 and 255).\n\n\nThe CPU is like a little office in the next building over.\nIt doesn&#8217;t understand what&#8217;s going on; all it does is take instructions and carry them out.\n\n\nOne instruction says to assign byte \\(\\text{2300003A}_{16}\\)[1] the value at byte \\(\\text{23000038}_{16}\\).\nThe CPU (office) requests for byte \\(\\text{23000038}_{16}\\) from the RAM (warehouse), and so the workers at the warehouse retrieve this data for the CPU.\nThe CPU then reads that the data is \\(\\text{00}_{16}\\), and so tells the warehouse to assign byte \\(\\text{23000038}_{16}\\) the value \\(\\text{00}_{16}\\).\n\n\nThis is what an assignment between variables actually is[2]: the CPU requests from RAM, then tells RAM to change a value.\n\n\nNow, most types take more than one byte, but the same process still works.\nIf you&#8217;re using ints (four bytes), then the CPU will request four bytes and tell memory to assign four bytes.\nIf you&#8217;re working with floats (four bytes), then the CPU will request and ask to write four bytes, but will use floating-point operations instead.\n\n\nConsider what the following code does:\n\n1\n2\n    int i = 0, j = 5;\n    int k = i + j;\n\nThe CPU, reading these instructions, will assign memory values to each int.\nIf we say that i is address 100, j is at 104, and k is at 108, then the process will be something like this:\n\n\n\n\nCPU tells RAM to assign 100 (four bytes) to 00000007\n\n\nCPU tells RAM to assign 104 (four bytes) to 00000005\n\n\nCPU requests the values of addresses 100 (four bytes) and 104 (four bytes), obtaining 000000007 and 00000005\n\n\nCPU adds these values together , obtaining 0000000C\n\n\nCPU tells RAM to assign 108 (four bytes) to 0000000C\n\n\n\n\n\nType Modifiers\n\nNotice that we are specifying how many bytes to to assign and request.\nWhat if we only needed to use two bytes for our variable?\nWhat if we needed more than four bytes, because we expect to use numbers larger than \\(2,147,483,647\\)?\nWhat if we don&#8217;t need to store negatives in our variable?\n\n\nThis is where type modifiers come in.\nThey modify the lengths and behaviours of variables.\n\n\nThere&#8217;s a few you should know about:\n\n\n\n\nshort: halves the length of a variable.\nApplicable to int only.\n\n\nlong: doubles the length of a variable.\nApplicable to int, long[3], char, and double[4]\n\n\nunsigned: the first bit of the variable will now be used as another digit rather than a sign indicator.\nApplicable to int, long, and char.\n\n\nsigned: opposite of above. Not really too useful, since it isn&#8217;t really necessary much of the time.\n\n\nconst: prevents this variable from being altered.\nThis is actually a compile-time behaviour, and doesn&#8217;t affect how the hardware handles things.\n\n\nstatic: declares this variable with a global lifetime, despite that it may be in a non-global scope.\nNot particularly useful for your purposes.\n\n\n\n\nThere are many questions where you may be asked to compute something very large; these are where long longs become vital.\n\n1\n2\n3\n    short int si;       //declare a short int (2-byte int) called si\n    long long ll;       //declare a long long (8-byte int) called ll\n    unsigned int ui;    //declare an unsigned int (4-byte u-int) called ui\n\nOftentimes the standard library will use types like uint32_t, or size_t.\nThe &lt;stdint.h&gt; and &lt;stddef.h&gt; libraries contains these types.\nIf you get compiler errors that mention these, now you might know what the heck they are!\n\n\n\nPointers\n\nRecall our little exercise at the end of the Variables in Memory section.\n\n\nAddresses are just numbers&#8201;&#8212;&#8201;four-byte numbers, at that, if you&#8217;re running 32-bit programs[5].\nWhat if you wanted to say \"hey, get me the value stored at the address indicated by that variable\"?\n\n\n\n\n\nEssentially, you&#8217;re setting a variable to reference some address in memory.\n\n\nNow, they&#8217;re not actually references.\n\n\n\n\n\nImportant\n\n\n\nPointers are not actually references.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPointers are not actually references.\n\n\n\n\n\n\nPointers merely store a number.\nWhen interpreted as a pointer, it refers to an address.\nBut this is only when interpreted with the right instructions.\n\n\nChanging the value of the pointer itself will only move the \"arrow of reference.\"\nIt doesn&#8217;t change what the pointer is pointing to.\n\n\nTo use it, you must dereference it first by telling the CPU, \"hey, instead of just changing this address (the pointer), change the address (the address \"referenced\" by the pointer) that this address (the pointer) stores.\"\n\n\nTake a second to digest that sentence; the distinctions are important.\n\n\nThere&#8217;s a few new operations you now need to know:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n    int a = 5;\n    int *p;\n    p = &amp;a;\n    *p += 50;\n    new p[a];\n    *p = 0;\n    *(p+1) = 1;\n    p[2] = 2;\n    delete[] p;\n    p = NULL;\n\n\n\nLine 2: when declaring a pointer, an asterick must be placed before the variable name, which denotes it as a pointer.\nThis is a type modifier, applicable to all types[6].\nWhitespace does not matter: int * p, int* p, int *p, int*p all do the same thing[7].\n\n\nLine 3: to set a pointer point to another variable, use the addressof operator. In C++, that&#8217;s &amp;.\n\n\nLine 4: to actually use the memory you&#8217;re referring to, you have to dereference a pointer with the dereference operator *[8]\n\n\nLine 5: you can dynamically allocate memory using the new and new[] operator. In this case, p became a pointer \"pointing to an array\"[9] of length 55 (that was the value of a).\n\n\nLine 6: dereferencing p now refers to the \"first element\" of \"the array\".\n\n\nLine 7: to access the next element, go 1 block after the location specified by p. This is why arrays are zero-indexed.\n\n\nLine 8: as a shorthand to the previous notation, you can use the index operator for quick pointer arithmetic.\n\n\nLine 9: when you&#8217;re done with memory, delete it.\nIf you keep asking for more memory, then you&#8217;ll run out sometime and you&#8217;ll get a segfault.\nNo one likes a segfault.\n\n\nLine 10: if a pointer isn&#8217;t in use&#8201;&#8212;&#8201;that is, it&#8217;s not referring to anything useful&#8201;&#8212;&#8201;then it should be assigned to NULL.\nAttempting to dereference a null pointer will immediately crash your program, which will immediately tell you whether or not you&#8217;ve made an incorrect reference.\n\n\n\n\n\n\n\nImportant\n\n\n\nWhy use null pointers if they&#8217;ll crash your program?\nThe alternatives are likely worse.\n\n\nIf you delete memory, but leave your pointer pointing to that deleted (no longer yours) memory, you&#8217;ll have a dangling pointer.\nSome other process might then grab that memory.\nWhat if that other process is your operating system?\n\n\nWhat if you then write over that memory that your operating system is using?\n\n\nAt least you can check if a pointer is null by checking equality: p == NULL.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that with pointer arithmetic we can pretty much add or subtract anything we want.\nIf you really wanted, you can try accessing p[55], despite it being past the length of the array.\n\n\nOr p[-1].\n\n\nBe careful when using pointers and indicies in C++; you&#8217;ll need to keep track of everything yourself.\n\n\n\n\n\n\nBecause of how pointers can be used to dynamically refer to memory, they are extremely helpful.\n\n\nMemory and String Manipulation with &lt;string.h&gt;\n\nRecall that in the last lesson that I mentioned that you can use char[] for strings.\nSince char*[10] can also be an array of char, they can also be strings.\nIn C, this is exactly what strings are: char*.\n\n\nMemory and string manipulation in the &lt;string.h&gt; library work exclusively with pointers.\nThe most important function you need to know is memset().\n\n\nIf you&#8217;d like to really practice working with pointers, try writing your own versions of some of the functions in &lt;string.h&gt;, starting with memset() and memcpy().\n\n\n\nPointers in STL Functions\n\nMany functions in the standard library use pointers to denote the beginning and end of ranges[11]:\n\n1\n2\n3\n4\n    int arr[]={9,8,7,6,5,4,3,2,1,0}; //size 10\n    std::vector&lt;int&gt; varr(arr, arr+10);\n    std::sort(arr, arr+10);\n    std::cout &lt;&lt; std::min_element(arr, arr+10);\n\n\n\nLine 2: you can construct an std::vector from an array with its range constructor.\n\n\nLine 3: you can sort a range with std::sort.\n\n\nLine 4: you can find a minimum element with std::min_element.\n\n\n\n\n\nMultidimensional Arrays\n\nIn many languages, you can have multidimensional arrays.\nIn C++, we don&#8217;t worry about classifying what arrays are single-dimensional and what are multidimensional, because a two-dimensional array is just an array of arrays[12].\nA three-dimensional array is just an array of arrays of arrays.\n\n1\n2\n3\n4\n5\n6\n7\n8\n\t//make a 10x10 multiplication table\n    int **two_d_arr = new int*[10];\n    for (int i = 0; i &lt; 10; ++i)\n    {\n        two_d_arr[i] = new int[10];\n        for (int j = 0; j &lt; 10; ++j)\n            two_d_arr[i][j] = i * j;\n    }\n\nLine 7 is equivalent to *(*(two_d_arr+i)+j) = i * j;\n\n\n\n\n\n\n\n\n1. this is hexadecimal, a 16-digit base (or radix) for numbers. It&#8217;s a common way to represent binary numbers, since it&#8217;s much more compact than writing every bit out. This way, each digit represents one nibble, or half-byte.\n\n\n2. actually there&#8217;s also the cache between the RAM and CPU, which speeds up this retrieval process. But that&#8217;s not so important to know right now.\n\n\n3. due to legacy issues, the long is a 4-byte int. long int may actually refer to a 4-byte int depending on your operating system, and so if you want an 8-byte int you&#8217;ll need a long long.\n\n\n4. actually, it makes doubles 12 bytes long up from 8 bytes; doubles are already  \"long floats.\"\n\n\n5. if you&#8217;re running 64-bit programs, they&#8217;re eight bytes.\n\n\n6. a pointer is a type, and so you can have a pointer to a pointer. Or a pointer to a pointer to a pointer. Or a pointer to a pointer to a pointer to a pointer to a pointer&#8230;&#8203; you get the point. You&#8217;d declare it as int ***** fifth_dimentional_pointer.\n\n\n7. you can declare different levels of pointers on the same line: int a, *b, **c gives you an int a, a pointer to int b, and a pointer to a pointer to int c.\n\n\n8. the dereference operator has a lower precedence than the access operator .; if you&#8217;re using a pointer to a struct or class, then you need specify that you&#8217;re dereferencing first: (*obj).member. There is a shorthand for this: obj->member does the same thing.\n\n\n9. it isn&#8217;t, it&#8217;s pointing a memory location which the operating system treats as a contiguous block of memory. It can act like an array, but it needn&#8217;t.\n\n\n10. pointer to char\n\n\n11. if you have two pointers, l, the \"beginning\" of the range, and r, the end, then the range will include l and exclude r. In interval notation, that&#8217;s [l,r).\n\n\n12. actually, \"multidimensional arrays\" as a specific type do have some optimizations over \"arrays of arrays\", but they aren&#8217;t particularly important here.\n\n" },"lessons-advanced-standard-io":{ url:"/lessons/advanced/standard-io",title:"Standard I/O",subclub:"advanced",content:"\n\n\nstd::cout and std::cin from the &lt;iostream&gt; library is bad.\n\n\nNow that you can use pointers, you should be using printf and scanf from the &lt;stdio.h&gt; library.[1]\n\n\nPractice this by redoing some WCIPeg questions.\n\n\n\n\nWhy &lt;stdio.h&gt; is better\n\n\nThe following two snippets of code do the same thing[2]:\n\n1\n2\n3\n4\n    std::string name;\n    int age;\n    //...\n    std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and you are \" &lt;&lt; age &lt;&lt; \" years old.\" &lt;&lt; std::endl;\n1\n2\n3\n4\n    std::string name;\n    int age;\n    //...\n    printf(\"Your name is %s and you are %d years old.\", name.c_str(), age);\n\nWhich looks easier to read?\n\n\nThe following two snippets of code do the same thing:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\n    //...\n    std::string name[30];\n    int age[30];\n    //...\n    std::cout &lt;&lt; std::left &lt;&lt; std::setw(20) &lt;&lt; \" Name\" &lt;&lt; std::right &lt;&lt; std::setw(5) &lt;&lt; \"Age\" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; 30; ++i)\n        std::cout &lt;&lt; \" \" &lt;&lt; std::left &lt;&lt; std::setw(19) &lt;&lt; name[i] &lt;&lt; std::right &lt;&lt; std::setw(5) &lt;&lt; age[i] &lt;&lt; std::endl;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n    //...\n    std::string name[30];\n    int age[30];\n    //...\n    printf(\" Name                 Age\\n\");\n    for (int i = 0; i &lt; 30; ++i)\n        printf(\" %19s%5d\\n\", name[i].c_str(), age[i]);\n\nWhich do you think took longer to reference and write?\n\n\n\n\n&lt;stdio.h&gt; with std::string\n\n\nBefore scanning, reserve enough space in the string.\n\n\nThen just scanf(\"%s\", str.data());.\n\n\nTo print, just printf(\"%s\", str.c_str());.\n\n\n\n\n\n\n1. you don&#8217;t have to, of course, but we&#8217;ll be very disappointed.\n\n\n2. not exactly, the second one (with &lt;stdio.h&gt;) actually works faster\n\n" },"lessons-advanced-introduction-to-algorithms":{ url:"/lessons/advanced/introduction-to-algorithms",title:"Introduction to Algorithms",subclub:"advanced",content:"\n\n\n\nalgorithm\n\nn. a process or set of rules to be followed in calculations or other problem-solving operations\n\n\n\n\n\nWhen we make a program, all we are doing is writing a set of instructions for computer to follow.\nThese instructions, of course, must be perfect&#8201;&#8212;&#8201;they have to be simple enough for a computer to follow, since computers only know so much and can&#8217;t interpret a programmer&#8217;s intent.\n\n\nWith the introduction of modular programming, many oft-repeated calculations could be encapsulated into a function, and later these functions into libraries.\nStandard yet complicated procedures&#8201;&#8212;&#8201;like getting an integral input[1]&#8201;&#8212;&#8201;could be implemented with a simple function call.\n\n\nA simple program which takes two integral values and spits out its sum could be simplified to two variable decalarations, and two lines of code.\nIt&#8217;s juat a simple algorithm.\n\n\nMost algorithms, however, aren&#8217;t so simple. In Computer Science, algorithms are about somehow manipulating memory to solve computational problems in a timely manner&#8201;&#8212;&#8201;computers, after all, only know how to manipulate memory.\n\n\n\n\nTime Complexity: Measuring an Algorithm\n\n\nIt certainly wouldn&#8217;t be a stretch to say that some algorithms are better than others.\nIf, for example, you had the following problem:\n\n\n\n\nGiven a sorted (least-to-greatest) array of size n, find the index of a value m.\nIf it does not exist, result -1.\n\n\n\n&#8212; problem statement\n\n\n\nOne way would be to iterate along the list, checking each and every element to see if it&#8217;s the desired value.\nThis is called the linear search.\n\n\nAnother way, commonly called the binary search, leverages the fact that the array is sorted.\nIf one starts from the middle, they can easily cut the problem to half its size, as the desired value is on one side or the other and figuring out which side it&#8217;s on relies on a simple comparison.\n\n\nClearly, both will work&#8201;&#8212;&#8201;both algorithms will eventually find the answer.\nBut you can also make the observation that the binary search is better.\nIt&#8217;s not because it&#8217;s more sophisticated, but rather that it&#8217;s faster.\nIf you had a 1024-element array, you can expect the following number of iterations for each algorithm:\n\n\n\n\n\n\n\n\n\n\nLinear Search\nBinary Search\n\n\n\n\nBest Case\n1 iteration (once in 1024)\n1 iteration (once in 1024)\n\n\nAverage Case\n512 iterations\n9 iterations\n\n\nWorst Case\n1024 iterations (once in 1024)\n10 iterations (once in 2)\n\n\n\n\nSo, is binary search fifty times faster than linear search?\nWell, not exactly\n\n\n\n\n\n\n1. scanf() or std::cin\n\n" },"lessons-beginners-installing-an-ide":{ url:"/lessons/beginners/installing-an-ide",title:"Installing an IDE",subclub:"beginners",content:"\nIntroduction\n\n\nIn order to write code, it is recommended to use a program specifically\nmade for coding. An IDE is any program that code can be written on. IDE\nstands for Integrated Development Environment. An ideal IDE would\ninclude features such as a syntax-highlighter, a compiler, and a\ndebugger.\n\n\nBelow are two IDEs that are made for writing C++:\n\n\n\n\nCode::Blocks (recommended)\n\n\n\nCode::Blocks works best for smaller programs and files (such as files\nsubmitted for contests)\n\n\nCan work for Windows, Linux, and Mac\n\n\nDownload Link\n\n\n\nWhen using Windows, install the Code::Blocks-16.01mingw-setup.exe\n\n\n\n\n\n\n\n\nVisual Studio\n\n\n\nVisual Studio works best for larger projects\n\n\nRequires Microsoft account\n\n\nDownload Link\n\n\n\n\n\n\n\nThis doc will walk through the usage of Code::Blocks.\n\n\n\n\n\nSetting up Code::Blocks\n\n\nIf Code::Blocks is running on Mac OS, the program will urge that command\nline must be downloaded. Allow Code::Blocks to install command line.\n\n\nOnce Code::Blocks finishes installing, click Settings on the top\ntask bar, then click compiler…\n\n\n\n\n\n\n\nOn the Global compiler settings tab, ensure that GNU GCC Compiler\nis the selected compiler. If the program is complaining that it cannot\nfind that compiler, click on Reset defaults.\n\n\nIf Code::Blocks still complains, Google is your friend! Welcome to\nMarkville’s Computer Science Course :D.\n\n\n\n\nSetting up a C++ File\n\n\nTo create a new C++ file, click on File on the top left corner of\nthe window.\n\n\n\n\nSelect File &gt; New &gt; Empty File\n\n\n\n\n\n\n\n\n\nPressing Ctrl-S or going to File &gt; Save will save your code. When\nsaving, ensure that the file name of your code ends with .cpp and not\n.c. The extension defines whether the document is a C file or a C++\nfile. A lot of material in this course cannot be used in a C file.\n\n\n\n\n\n\n\nPressing F2 or going to View &gt; Logs will display an extra window on\nthe screen. This screen will be important for debugging code.\n\n\nOn the empty file, there should be line numbers shown on the left. If\nthe line numbers do not show for some reason, go to Settings &gt; Editor\n&gt; Other editor settings and check the box with Show line numbers\nbeside it.\n\n\n\n\nIn Summary:\n\n\n\n\nAn IDE is a program that allows users to write and execute code\n\n\nVisual Studio and Code::Blocks are common IDEs\n\n\n\n\n" },"lessons-beginners-the-structure-of-a-c-file":{ url:"/lessons/beginners/the-structure-of-a-c-file",title:"The Structure of a C++ File",subclub:"beginners",content:"\nIntroduction\n\n\nA computer is designed to follow instructions and commands. Typically,\nthese instructions are organized into a file that the computer follows\nand executes. These formatted instructions are known as code.\nEssentially, code is a set of commands given to a computer to execute.\n\n\nWhen reading a file of code, the computer goes through each line and\nexecutes every command one at a time in order.\n\n\nThe basic skeleton of a C++ file will resemble the following:\n\n1\n2\n3\n4\n5\nusing namespace std;\n\nint main() {\n    return 0;\n}\n\nIn C++, each component of this skeleton is required in order for the\ncode to properly run.\n\n\n\n\nLibraries\n\n\nThere are files that store all the possible instructions C++ could\nrecognize. All the commands that the computer understands and could\nexecute are placed in a file called a library. A library stores a list\nof commands that the computer could follow. If a computer has access to\na library, it could perform any command that is listed in that library.\n\n\nThe most common library that is used when coding a C++ file is the\nstandard library.\n\n\nFor beginner purposes, all commands that will be used when coding will\nbe in the standard library.\n\n\nTo tell the computer that a file will use the standard library, using\nnamespace std; is placed at the beginning of the file.\n\n\n\n\n\nNote\n\n\nAlways include libraries at the beginning of a C++ file.\n\n\n\n\n\n\n\nThe Main Function\n\n\nWhen a computer first runs a code file, it will go down each line of\ncode until it reaches a line with int main(). This line is referred to\nas the main function. Once the computer finds the main function, it\nwill begin executing all commands listed inside the braces (\\{}). Any\ncommands that are in the file must be placed within the main function.\n\nint main() {\n    return 0;\n}\n\nThe computer reads and executes each line of code in the main function\nand ends once it has reached the line return 0;. Any line of code that\nfollows this line will be ignored. A C++ file should always have\nreturn 0; within its main function.\n\n\n\n\nWhitespace\n\n\nWhitespace is any part of a file that is intentionally left blank. This\nincludes spaces, indents, and empty lines. Unlike some other computing\nlanguages (e.g. Python), the amount of whitespace that is left in a C++\nfile has no effect on the computer’s performance when it is executing\nthe code. So both of the following examples are identical:\n\n\nExample 1:\n\nusing namespace std;\n\nint main() {\n    return 0;\n}\n\nExample 2:\n\nusing namespace\nstd;\nint\nmain(){return 0;}\n\nThough not required, it is encouraged to develop a habit of using\nwhitespace in order to make a C++ file easier to read. This includes\nindenting any commands that are within the main function.\n\n\n\n\nComments\n\n\nApart from having computers skip over any whitespace, the computer could\nalso be told to skip any text in a file while executing the code. A\ncomment is any text in a file that is not meant for the computer to\nread. Users put important information about the file into the code as\ncomments. Overall, comments makes code more readable for humans.\n\n\nExample:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nusing namespace std;\nint main(){\n    // This is a comment.\n    /*\n        Everything between the\n        2 symbols are comments.\n    */\n    return 0;\n}\n\nThere are two main methods for adding comments into a C++ file. Adding\n// will have the computer skip all remaining text in a line of code.\n\n\nAll text that is enclosed by /* and \\*/ are commented out and not\nread by the computer.\n\n\n\n\nIn Summary\n\n\n\n\nA library is a file that stores a list of commands that a computer can\ndo\n\n\nusing namespace std; makes your computer able to use the standard library\n\n\nAll code must be placed in the main function\n\n\nreturn 0; should always be placed at the end of the main function\n\n\nWhitespaces are any spaces, indents, and empty lines\n\n\nWhitespace is used to organize code to make it more readable\n\n\nComments can be used to add remarks/explanation about the code\n\n\n\n\n" },"lessons-beginners-simple-outputs":{ url:"/lessons/beginners/simple-outputs",title:"Simple Outputs",subclub:"beginners",content:"\n\n\nGoal: To be able display numbers and text onto a screen\n\n\n\n\n\n\n\nIn order for a computer to take a file and execute its code, it must be\ntold to build and run the code. On Code Blocks and Visual Studio, press\nF9 or click the Build and run option on the Build drop-down menu\nto build and run a code file.\n\n\nWhen told to build and run a file, the computer will create an .exe\nfile located alongside the .cpp file. However, .exe files cannot be\nsaved onto a school computer. Thus, the .cpp file should be located on\nan external hard drive such as a USB when using school computers.\n\n\n\n\n\nRunning the basic skeleton listed previously will create a window\nresembling the following:\n\n\nThis window is known as the console. This is the text-based interface\nthat accepts inputs from users and displays output values onto the\nscreen. (Graphics will be done at a later time.) The text from the\nconsole shown above only appears once the computer finishes running the\nfile.\n\n\n\n\nProcess returned 0 (0x0) corresponds to the return 0; line in the main\nfunction of the code file.\n\n\nThe execution time is the amount of time the computer took to run the\nprogram.\n\n\nPressing any key will close the console window.\n\n\n\n\n\n\nOutputting Values\n\n\nThe simplest command for C++ that outputs text onto the console is the\ncout command. cout is a command that is not located in the Standard\nLibrary. Instead, it is located in the &lt;iostream&gt; library.\n\n\nIn order to add any library into a C++ file, add\n#include followed by the name of the library, at the top of the\nfile.\n\n#include &lt;iostream&gt;\n\n\n\n\nNote\n\n\nAlong with using namespace std; all #include statements should be\nplaced at the beginning of the file\n\n\n\n\n\ncout stands for &#8220;Console OUTput&#8221;, and it allows the console\nto output text and numbers onto the screen. In code, the cout command is\nformatted like so:\n\ncout &lt;&lt; Output &lt;&lt; endl;\n\nThe output is enclosed between two &lt;&lt; and can be one of 2 types.\n\n\n\n\nComputers could output numbers (real or integer) onto the screen\n\n\nText (also known as string literals) can be outputted onto the screen\n\n\n\nString literals must be enclosed by quotation marks (\"\")\n\n\n\n\n\n\n\nTable 1. Components of the cout command:\n\n\n\n\n\n\ncout\nThis marks the beginning of the output command and tells the\nconsole that a value will be outputted\n\n\n&lt;&lt;\n\nThese symbols must be placed in between all outputs in the command.\n\n\nTip: to remember the direction of the symbol, when looking from left to\nright, the symbol goes outwards\n\n\n\nendl\nThis tells the console to skip to the next line. This part is not\nrequired in the syntax of cout.\n\n\n\n\n\n\n\nNote\n\n\nLike all other commands on C++, the cout command must end with\na semicolon (;). This marks the end of a command for a compiler.\n\n\n\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n#include &lt;iostream&gt;           // library with cout\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Line 1\" &lt;&lt; endl; // Text on line 1\n    cout &lt;&lt; 12;               // There is no endl\n    cout &lt;&lt; 3.45;             // outputs on 2nd line\n    return 0;                 // ends program\n}\n\nOutput:\n\n\n\nLine 1\n123.45\n\n\n\nMultiple outputs can be displayed using one command simply be separating\neach output with &lt;&lt;. The following code has an identical output as the\ncode above.\n\n1\n2\n3\n4\n5\n6\n7\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Line 1\" &lt;&lt; endl &lt;&lt; 12 &lt;&lt; 3.45;\n    return 0;\n}\n\n\n\nIn Summary:\n\n\n\n\nBuilding and running a code file will create a .exe file and open a\nwindow called a console\n\n\nThe console is able to accept user inputs and display text and values\n\n\nThe cout command tells the computer to output a value onto the console\nwindow\n\n\nPutting #include &lt;iostream&gt; in the file will add cout to the computer’s\nlist of known commands\n\n\nText outputs must be enclosed by quotation marks\n\n\nAll commands must end with a semicolon\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nCreate a C++ file called HelloWorld.cpp that outputs “Hello, World!”\nonto the screen\n\n\nExplain the difference between the two statements and their outputs.\n\n\n\ncout &lt;&lt; \"08\" &lt;&lt; endl;\n\n\ncout &lt;&lt; 08 &lt;&lt; endl;\n\n\n\n\n\nPredict what the console will output given the following code:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"01\" &lt;&lt; endl &lt;&lt; 12;\n    cout &lt;&lt; \" \" &lt;&lt; 3.58;\n    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; \"13\";\n    return 0;\n}\n\n\n\n\n" },"lessons-beginners-simple-operators":{ url:"/lessons/beginners/simple-operators",title:"Simple Operators",subclub:"beginners",content:"\n\n\nGoal: Have computers be able to use operators and perform basic calculations.\n\n\n\n\nIntroduction\n\n\nComputers are machines that are made to do calculations. In fact, they\nspecialize in performing operations and manipulating any given data.\n\n\nOperators are symbols that signal the computer to perform a task with a\ngiven value(s). An example of an operator in code is the &lt;&lt; found in\nthe cout command. Operators are able to add, assign, or compare values.\nThis chapter will focus specifically on arithmetic operators,\noperators that take numbers and return a single numerical value.\n\n\nIn C++ (and most other languages), the + is used to add two numbers\ntogether. A line of code in which operators are used is called an\nexpression. For example, 5 + 3 and 1 + 2 + 3 + 4 are considered to be\nexpressions. When given an expression, the computer will always attempt\nto evaluate the expression and return a single numerical value.\n\n\n\n\nUsing Operators with Outputs\n\n\nWhen putting operators onto an output command, arithmetic operators will\nnaturally take priority over &lt;&lt;. This means that the computer will\nevaluate an expression between a set of &lt;&lt; before outputting.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"5 + 3 = \" &lt;&lt; 3 + 5 &lt;&lt; endl;\n    4 + 4;             // semicolon\n    return 0;\n}\n\nOutput:\n\n\n\n5 + 3 = 8\n\n\n\nIn the output statement in the code above (Line 5), the computer will\nfirst output the text 5 + 3 = . Since the + is enclosed with\nquotations, the symbol is considered to be a character in text and not\nan operator. In the next portion of the output statement, there is an\nexpression in which 3 and 5 are added. The computer will first evaluate\nthe expression and result a number (In this case, it would be 8). Then,\nit will output that number onto the screen. Once done the output\nstatement, the computer will then evaluate 4 + 4 located on the next\nline. However, the calculation is useless as the computer has nothing to\ndo with the number returned from the expression. Thus, the computer\nsimply continues to the next line of code.\n\n\nNOTE:\nArithmetic Operators are not meant for text. Do not try to add or\nsubtract text in a code file using these operators. Definitely do not\nthink about adding text with numbers.\n\n\nBelow is a list of some arithmetic operators (and more) available for\nC++.\n\n\n\n\n\n\n\n\n\n\n\nName\nSyntax\nDescription\nExample\nOutput\n\n\n\n\nAddition\n+\n\nAdds two numbers together\n\n\n8 + 3\n\n\n11\n\n\n\nSubtraction\n-\n\nSubtracts two numbers together\n\n\n8 - 3\n\n\n5\n\n\n\nMultiplication\n*\n\nMultiplies two numbers together\n\n\n8 * 3\n\n\n24\n\n\n\nDivision\n/\n\nDivides the first number by second number\n(Will drop the remainder when dividing integers)\n\n\n8 / 3\n8.0 / 3\n\n\n2\n2.66667\n\n\n\nModulo\n%\n\nFinds the remainder when first num is divided by the second number\n\n\n8 % 3\n9 % 3\n9 % 4\n\n\n2\n0\n1\n\n\n\nParenthesis\n()\n\nDictates the order in which operations are done. Prioritizes all\noperators inside parenthesis.\nTechnically not an arithmetic operator.\n\n\n2 * (8 - 3)\n\n\n10\n\n\n\n\n\nA list of these operators and more are found in\nList\nof Operators doc shared with you.\n\n\n\n\nOrder of Operations\n\n\nGenerally, the order of operations for arithmetic operators will be\nsimilar to BEDMAS/PEMDAS. Division, multiplication, and modulo will\ntypically be executed before addition or subtraction. However, adding\nparenthesis to an expression will help ensure that the expression will\nalways run the way that it is intended to. There is no consequence for\nputting excessive amounts of parenthesis in an expression (Other than\nreadability).\n\n\nClick\nhere to see a chart displaying the order of operations.\n\n\n\n\nIn Summary\n\n\n\n\nOperators are symbols that manipulates data values\n\n\nArithmetic Operators are operators that deal with numeric values\n\n\nAn expression consists of a combination of numbers and arithmetic\noperators\n\n\nExpressions are able to be placed within an output statement\n\n\nParenthesis are used to change the order in which operators are\nperformed\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nCreate a program called 42.cpp. Since 42 is the answer to life, the\nuniverse, and everything, your job is to have your code output the\nnumber 42 in five different ways, using each operator at least once.\n\n\nJimbob, being the beginner that he is, is confused on why his code\noutputs -1 and not 2. Your goal is to add parenthesis to Jimbob’s code\nin order for his code to output 2.\n1\n2\n3\n4\n5\n6\n7\n8\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    cout &lt;&lt; 14/6+4/5%8-3;\n    //arithmetics are hard\n    return 0;\n}\n\n\n\n\n" },"lessons-beginners-an-introduction-to-variables":{ url:"/lessons/beginners/an-introduction-to-variables",title:"An Introduction to Variables",subclub:"beginners",content:"\n\n\nGoal: To be able to incorporate variables with outputs and operators\n\n\n\n\nWhat is a Variable?\n\n\nConsider a folder that is used to store a sheet of paper. This folder\ncan only hold one sheet of paper at a time. The folder is given a name,\nand the information inside of the folder can be accessed and referred to\nif the name of the folder is known. The contents of the folder could be\nchanged at any time and all previous information that was kept in the\nfolder is thrown out.\n\n\nA variable works similar to the folder in this analogy. A computer has a\nstorage system inside that is called memory. Parts of memory can be\nused to store data and information for later use. A variable sets\nup/allocates a section of memory to be used in a file. Only one piece of\ndata can be stored in a section of memory at a given time. The data\nlocated in the memory can be changed and accessed at any given time so\nlong as the address/the variable storing the memory is known.\n\n\nIn general, variables are a means of storing data. Without variables and\nmemory, the computer has no way of storing any information that is\ngiven.\n\n\n\n\nParts of a Variable\n\n\nA variable consists of many components. Most notably, variables will\nalways have a name and a type.\n\n\nNormally, memory will be accessed by having an address. This address is\nexpressed as a hexadecimal number (A minor inconvenience for humans to\nread). Variable names are simply labels that humans use to refer to data\nlocated in a part of memory. A code file will typically refer to\nspecific parts of memory by using variable names. Using the folder\nanalogy, the name will simply be the name of the folder.\n\n\nA variable type tells the computer what type of data this variable will\nbe receiving. Each variable type in C++ has their own format and takes\nup a certain amount of memory. That being said, it is important for the\ncomputer to know whether it is working with integers or characters. A\nvariable cannot store a piece of data that is of a different type nor\ncan it change type altogether.\n\n\nThere are many types of variables available for C++, but below is a list\nof the most prominent variable types in C++\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nExamples\n\nIntegers (int)\n\n\n\nIncludes positive and negative numbers.\nDoes not include decimals\n\n42\n-6\n\n\n\nCharacters (char)\n\nLetters, numbers, all\nASCII Characters\n\n\n\n&amp;\n\nFloating Numbers (float)\n\n\n\nFloating numbers are basically real numbers.\nAlways use integers over floating numbers whenever possible. Integers\nare more reliable and will cause less random bugs.\n\n3.1415\n1.0\n-0.1235\n\n\n\nBoolean Values (bool)\n\nValues that are either true (1) or false (0).\nThis variable type takes the least memory/space.\n\n\n\n\n\nFor more information about theses variable types, as well as information\nabout other variable types, refer to the\nVariable\nTypes doc that is shared with you.\n\n\n\n\nInitializing a Variable\n\n\nIn order for a computer to use a variable, it should first be told that\nthis variable exists and it has access to it. When a computer is told to\ninitialize a variable, it is allocating space/making room in the Random\nAccess Memory (RAM) for the computer to quickly use to store and\nretrieve data. The way a variable is initialized resembles the\nfollowing:\n\n\n\n&lt;variable type&gt; &lt;variable name&gt;;\n\n\n\nThe type of variable will be listed first, followed by the variable name\nand a semicolon.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n//Examples of Variable Initializations\nusing namespace std;\n\nint main() {\n    int mark; // integer variable\n    char firstInitial; // character variable\n    bool isPassing; // boolean variable\n    return 0;\n}\n\nThings to avoid when thinking of variable names:\n\n\n\n\nGiving 2 variables the same name\n\n\n\nIn this case, the computer would not know which variable is being\nreferred to\n\n\n\n\n\nHaving the name of the variable be the name of a command for C++\n\n\n\nUsually variable names and commands are in different colours in an IDE\nVariable Assignment\n\n\n\n\n\n\n\nIn order to store data into a variable, an equal sign (=) operator is\nused in C++.\n\n\n\nvariableName = dataValue;\n\n\n\nThe variable to assign is placed on the left side of the equal sign and\na value/expression is placed on the right side. The expression on the\nright side will be evaluated and the value is stored into the variable.\nIf the variable already has data stored in it, that data will be\noverwritten with the new value it is given.\n\n\n\n\n\nNote\n\n\nAll characters in a code file must be enclosed by single quotation marks. ('')\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nusing namespace std;\n\nint main(){\n    char c;\n    c = 'A'\n    bool checked;\n    checked = false;\n}\n\n\n\nAccessing a Variable\n\n\nPutting the variable name into the code will have the computer access\nthe data stored in that variable. When variables are used in an\nexpression, the variable name in the code will be substituted with the\nvalue that the variable is storing, and the expression will be\nevaluated. If the computer attempts to access data in a variable when\nthere is no data assigned, it will return a garbage number, a number\nthat has no relevancy.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nusing namespace std;\n\nint main() {\n    int num, num2;      // multiple variables of the same type can be\n                        // initialized at once.\n                        // variables must be separated by commas\n    num = 5;\n    num2 = num + 4;     // num2 = (5) + 4       num2 = 9\n}\n\nSince the value on the right side of the assignment will be evaluated\nbefore it is assigned into the variable on the left side, the same\nvariable can appear on both sides of the assignment.\n\n1\n2\n3\n4\n5\n6\n7\n8\nusing namespace std;\n\nint main() {\n    int num;            // initializes variable\n    num = 6;\n    num = num + 1;      // 6 + 1 = 7\n    num = num * num;    // 7 * 7 = 49\n}\n\nLike output commands, ensure that variable initialization and\nassignments all end with a semicolon.\n\n\n\n\n\nNote\n\n\nThere are no such things as equations in code. Having an equal\nsign does not mean that the left side is equal to the right side. It is\nsimply assigning the variable on the left side to the value on the right\nside.\n\n\n\n\n\n\n\nIn Summary:\n\n\n\n\nComputers keep data in their internal storage system called memory\n\n\nVariables allocates some memory in your RAM in order to store data\n\n\nVariables always come with a type and a name\n\n\nBefore using a variable, they must first be initialized through variable\ninitialization\n\n\nValues can be assigned to a variable using the equal operator (=)\n\n\nExpressions on the right side of a variable assignment may include\noperators and variables\n\n\nTrying to access data from a variable when no data is assigned will\nreturn a garbage value\n\n\n\n\n\n\nPractice Questions:\n\n\n\n\nCreate a .cpp file called swap.cpp that has 2 variables, a = 10 and b =\n1\n\n\n\nYour goal is to swap the values of the 2 variables and output them\nwithout putting a = 10 or b = 1\n\n\n\n\n\n\n\n\n\n\nFurther Reading for Variables\n\n\nVariable initialization and variable assignment can be combined into one\nline like so.\n\nint num = 8;\nint num2 (8);\n\nSigned Integers vs. Unsigned Integers\n\n\n\n\n\n\nA computer stores data as a string of either 0s or 1s called bits. The\nmore memory a data value needs, the more bits are required to store that\ndata. Eight bits make up a byte, and an integer uses up 4 bytes of\nmemory. An integer variable uses enough bits to have each permutation of\n0s and 1s represent a unique integer. When an integer variable is\nstored, the first bit is always used to indicate whether the integer is\npositive or negative. Integers that can be positive or negative are\ncalled signed integers.\n\n\nSometimes, integers may be used in ways so that they will never become\nnegative. This makes the one bit storing the sign of the integer quite\nwasteful. Unsigned integers omit the possibility of having negative\nnumbers. The bit that is used from storing the sign will instead be\nused to store more positive numbers. Overall, unsigned integers are not\nnecessary, but they can maximize the effectiveness of a variable with\nthe same amount of memory.\n\n\n\nLong Long and Shorts\n\nAn int variable is able to store any number from -2 147 483 648 to 2 147\n483 647. If the data values being used get so large that it exceeds the\nrange of an int variable, another variable type would be used. Long\nlong are variable types that take up twice as much memory than an int\ntype. Because of that, it is able to store integers from -9 quintillion\nto 9 quintillion. Since this data type does take up more memory than int\ntypes, it is advised not to use long longs unless absolutely necessary.\n\n\nA short is a variable integer type that takes up less memory than an\nint variable type. Understandably, a short can only store integers from\n-32 768 to 32 767. Both long long and short variable types can be signed\nor unsigned.\n\n\n\nAssignment Operators\n\nThe equal sign belongs to the collection of operators called assignment\noperators. These operators are used to assign data to variables and\nthey are all modified versions of the basic operator =.\n\n\nThe following is a list of most of the assignment operators.\n\n\n\n\n\n\n\n\n\n\n\nName\nSyntax\nDescription\nExample\nEquivalent Operation\n\n\n\n\nAddition Assignment\n+=\nAdds the current data value with another\nx +=\n3\nx = x + 3\n\n\nSubtraction Assignment\n-=\nSubtracts the current data value with\nanother\nx -= 4\nx = x - 4\n\n\nMultiplication Assignment\n*=\nMultiplies the current data value with\nanother\nx *= 2\nx = x * 2\n\n\nDivision Assignment\n/=\nDivides the current data value with another\nx\n/= 5\nx = x / 5\n\n\nModulo Assignment\n%=\nTakes the remainder when the current data value\nis divided by another value\nx %= 3\nx = x % 3\n\n\nIncrement\n++\nIncreases the current data value by 1\nx++\nx += 1\n\n\nDecrement\n&#8201;&#8212;&#8201;\nDecreases the current data value by 1\nx--\nx -= 1\n\n\n\n\nAlthough useful, these operators are not required when writing a\nprogram. However, these operators are often used in code to help with\nreadability.\n\n\n\n" },"lessons-beginners-simple-inputs-and-wcipeg":{ url:"/lessons/beginners/simple-inputs-and-wcipeg",title:"Simple Inputs and WCIPEG",subclub:"beginners",content:"\n\n\nany inputs that are given by users.\n\n\nThe library &lt;iostream&gt; not only has cout, a command that outputs\nvalues, but it also includes cin, a command that accepts inputs. cin\nstands for Console INput and its syntax is formatted as\nfollows.\n\ncin &gt;&gt; variableName;\n\nThe cin command uses &gt;&gt; in its format while cout uses of &lt;&lt;. To\ndifferentiate them, imagine the symbols as lines moving inwards (&gt;&gt;) or\nmoving outwards (&lt;&lt;). cin will tell the console to put all inputs into a\nspecified variable. Values cannot go into a cin command. Like cout,\neach cin command can accept multiple inputs by separating each variable\nname with &gt;&gt;.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n#include &lt;iostream&gt;\nusing namespace std;\n// This code takes two numbers and returns their sum\nint main() {\n    int num, num2;                       // initializes variables\n    cout &lt;&lt; \"Pick 2 numbers!\" &lt;&lt; endl;   // displays message\n    cin &gt;&gt; num &gt;&gt; num2;                  // receives input\n    // the first input is placed in num and the second is placed in num2\n    cout &lt;&lt; \"The Sum is \" &lt;&lt; num + num2; // outputs the sum\n    return 0;                            // returns 0\n}\n\nSample run:\n\n\n\n&gt;&gt;&gt; Pick 2 numbers!\n3\n87\n&gt;&gt;&gt; The Sum is 90\n\n\n\n\n\nWCIPEG\n\n\nWCIPEG is a website that has a collection of\ncoding problems from various computer science contests as well as a wiki\nfilled with useful information about coding algorithms. It also features\nan automated judge that will test any submitted code against its\nproblem. Users could submit their code to be tested by the judge.\n\n\nOnly registered users are able to use the online judge on the site. To\nregister, go to the WCIPEG main page and click on\nregister an account on the top right corner. To join the Markville\nSecondary School Organization on WCIPEG, go to My Account &gt; Edit\nUser Info, and select Markville Secondary School as your\norganization. :))\n\n\n\n\nDMOJ\n\n\nDMOJ is a website similar to WCIPEG that has\nproblems from past contests as well as problems from other sources for\nstudents to practice coding. It also features an automated judge.\n\n\nLike on WCIPEG, you will have to register an account on DMOJ. To\nregister, click the register button in the top right corner. Sadly,\nMarkville Secondary School isn’t an organization on DMOJ.\n\n\n\n\nSubmitting Code\n\n\nThe problems page will display a list of all problems that the online\njudge can test. The points represent the general difficulty of that\nproblem. (The easier problems are worth less\npoints)\n\n\n\n\n\n\n\n\n\nEach problem will ask for a specific output given a specific input. The\ndetails and examples of the problem are located on the contest problem\npage.\n\n\nOn the contest problem page, the Submit link will be located on the\nright side.\n\n\nCopy and paste the entire code or upload the code file into the\nsubmission page\n\n\nEnsure that the language chosen in the drop-down menu is C++ 03 (g\\\\\n4.1.3)\n\n\nPray that the code works and outputs all intended values.\nThis document, from now on, will mostly use contest questions found on\nthese sites for its practice questions. Expect that the contest\nquestions found in the CCC to be of similar nature to the questions on\nthese sites.\n\n\n\n\n\n\nIn Summary\n\n\n\n\ncin is a command found in the &lt;iostream&gt; library that takes a user input\nand stores it into a variable.\n\n\nWCIPEG and DMOJ are sites made for students to practice contest-styled\ncoding problems\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nA plus B\n\n\nTask R2\n\n\nCCC '10 J1\n\n\n\n\n" },"lessons-beginners-if-structures":{ url:"/lessons/beginners/if-structures",title:"If Structures",subclub:"beginners",content:"\n\n\nGoal: To be able to implement structures into code.\n\n\n\n\nRelational Operators\n\n\nRelational operators find any similarities between two values, typically\nvariables. A relational operator takes two values or expressions,\ncompares the two, and returns a boolean value. A boolean value comes\nin one of two states: true or false. For a computer, true is stored\nas a 1, and false is stored as a 0.\n\n\nAn example of a relational operator is ==. It checks whether two\nvalues/expressions are equal to each other. The symbol == is different\nfrom =, an operator only used for variable assignments. Be sure not to\nmix up the two operators.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; (3 == 3) &lt;&lt; endl;        // compares ints\n    cout &lt;&lt; (2.6 == 3) &lt;&lt; endl;      // compares double and ints\n    cout &lt;&lt; ('A' == 'A') &lt;&lt; endl;    // compares characters\n    cout &lt;&lt; (true == false) &lt;&lt; endl; // compares boolean values\n    return 0;\n}\n\nOutput:\n\n\n\n1\n0\n1\n0\n\n\n\n\n\n\nNote\n\n\n&lt;&lt; is an operator that is evaluated before relational operators.\nTherefore, when outputting values with relational operators, parentheses\nmust surround the relational operator.\n\n\n\n\n\nRelational operators are able to work with integers, floating numbers,\ncharacters, and boolean values. Values of different types can also be\ncompared to each other, although computers use complicated ways to\ncompare variable types such as characters.\n\n\nThe following are more examples of relational operators.\n\n\n\n\n\n\n\n\n\n\n\nName\nSymbol\nDescription\nExamples\nResult\n\n\n\n\nNot equal to\n\n!=\n\nChecks if two values are different\n\n3 != 4\n5 != 5\n\n\ntrue\nfalse\n\n\n\nGreater than\n\n&gt;\n\nChecks if the first value is greater than the second\n\n5 &gt; 0\n6 &gt; 6\n\n\ntrue\nfalse\n\n\n\nLess than\n\n&lt;\n\nChecks if the first value is less than the second\n\n3 &lt; 4\n5 &lt; 3\n\n\ntrue\nfalse\n\n\n\nGreater than or equal to\n\n&gt;=\n\nChecks if the first value is greater than or equal to the second value\n\n5 &gt;= 4\n4 &#8656; 4\n\n\ntrue\ntrue\n\n\n\nLess than or equal to\n\n&#8656;\n\nChecks it the first value is less than or equal to the second value\n\n3 &#8656; 3\n4 &#8656; 3\n\n\ntrue\nfalse\n\n\n\n\n\n\n\nLogical Operators\n\n\nMultiple comparisons can be done at once by using logical operators.\nThese logical operators are used to manipulate boolean values,\ntypically boolean values returned from relational operations. For\nexample, a computer can check if a number is both less than a certain\nvalue and greater than a certain value. Relational operators are\nperformed before logical operators. The following are examples of\ncommon logical operators.\n\n\n\n\n\n\n\n\n\n\n\nName\nSymbol\nDescription\nExamples\nResult\n\n\n\n\nAND\n\n&amp;&amp;\n\nReturns true only if both sides are true\n\ntrue &amp;&amp; true\nfalse &amp;&amp; true\n\n\ntrue\nfalse\n\n\n\nOR\n\n`\n\n\n\n`\n\n\nReturns true when either side is true\n\n\n\n`true\n\nfalse`\n`false\n\n\nfalse`\n\n\n\ntrue\nfalse\n\nNOT\n\n!\n\nReturns true if value is false and returns false if value is true\n\n\n!(true)\n!(false)\n\n\n\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; ((3 &lt; 4) &amp;&amp; (6 == 7)) &lt;&lt; endl;\n    cout &lt;&lt; (!(!(5 != 6) || !(4 &gt;= 4))) &lt;&lt; endl;\n    return 0;\n}\n\nOutput:\n\n\n\n0\n1\n\n\n\nTry to follow the process of the computer from all the inner brackets to\nthe outer brackets.\n\n\n\n\nIf Statements\n\n\nAn if statement is the simplest way of controlling the order in which\ncommands are executed. The order in which actions are executed is called\ncontrol flow. If statements basically tell the program to do a\nspecific set of commands if a certain condition is met.\n\n\nThe basic outline of an if statement looks like the following:\n\nif (condition) {\n    //code to be run if the condition results to true\n}\n// rest of the code\n\nInside the parenthesis will be a condition that will result either true\nor false. Normally, the if statement will have variables being compared\nusing relational operators and/or logical operators. Notice how the\ncondition does not need to end with a semicolon. Inside the braces of\nan if statement will be all the commands that the computer will execute\nif the condition results to true. If the condition results to false,\neverything inside the braces will be skipped. In order to make a code\nfile much easier to read, indenting all commands inside an if\nstatement is encouraged.\n\n\n\n\n\nNote\n\n\nDo not initialize a variable within an if structure and use that\nvariable outside the if structure. This subject will be explained in\nmore detail in the next chapter.\n\n\n\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n#include &lt;iostream&gt;     // this code will check if a number is positive\nusing namespace std;\n\nint main() {\n    int num;            // initializes an integer variable\n    cout &lt;&lt; “Type in any number.” &lt;&lt; endl;\n    cin &gt;&gt; num;         // gets user input\n    if (num &gt; 0) {      // all positive numbers are greater than 0\n        // if num is positive, this message will be displayed\n        cout &lt;&lt; num &lt;&lt; \" is a positive number.\";\n    }                   // if num is negative or zero, output is skipped\n    return 0;\n}\n\nSample Run:\n\n\n\nType in any number.\n8\n8 is a positive number.\n\n\n\nIn the example above, no message will appear if the number inputted is\nnegative or zero. In order to put a message stating that a number is\nnegative or zero, a second and third if statement could be added.\nHowever, there is a cleaner way to have the program output that message.\n\n\n\n\nElse and Else if Statements\n\n\nElse and Else if statements extend off the original if statement. They\nmake a program run a different set of commands if the conditions in an\nif statement results false. An if structure that includes an else if and\nelse statement will resemble the following:\n\nif (condition1) {\n    // code to be run if condition 1 results true\n}\nelse if (condition2) {\n    // code if condition 1 results false but condition 2 results true\n}\nelse if (condition3) {\n    // more code\n}\n// the number of else if statements could continue...\nelse {\n    // code to be run if all previous conditions result false\n}\n\n\n\n\n\n\nThe program will always check the initial condition first and will check\nfollowing conditions if all previous conditions result false. For\nexample, if condition 2 results to true, but condition 1 also results to\ntrue, the program will prioritize the first set of code. Once the\nprogram is done executing the commands inside an if, else if, or else\nstatement, the program will skip the rest of the if structure. This\nmeans that if the first condition results true, the program ignores all\nother if conditions inside the if structure. A program is able to have\nmultiple else if statements within one if structure. However, an if\nstructure can only have one else statement. Else if statements and else\nstatements are completely optional and either could be omitted from the\nif structure.\n\n\nBelow is the same code modified to display messages for positive,\nnegative numbers and zero.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int num;\n    cin &gt;&gt; num;\n    if (num &gt; 0) {        // all positive numbers are greater than 0\n        cout &lt;&lt; num &lt;&lt; \" is an even number.\"; // skips to line 16\n    }\n    else if (num &lt; 0) {   // all negative numbers are less than 0\n        cout &lt;&lt; num &lt;&lt; \" is a negative number.”; // skips to line 16\n    }\n    else {               // 0 is neither greater or less than 0\n        cout &lt;&lt; num &lt;&lt; \" is not positive nor negative.\";\n    }\n    return 0;\n}\n\n\n\nIn Summary\n\n\n\n\nRelational Operators compare two values/expressions and returns a\nboolean value\n\n\nLogical Operators manipulate boolean values and return one boolean value\n\n\nArithmetic Operators are executed before relational operators, which are\nexecuted before logical operators\n\n\nThe order in which a computer executes code is called control flow\n\n\nIf statements modify control flow by giving the program extra commands\nif a condition results to true\n\n\nelse if and else statements can be added to an if structure\n\n\nThe program, once finding a condition that results true in an if\nstatement, will perform all commands and immediately skip to the end of\nthe if structure.\n\n\n\n\n\n\nPractice questions\n\n\n\n\nLeap Year\n\n\nSpecial Day\n\n\nWho’s in the Middle\n\n\nTriangle Times\n\n\nMultiple\n\n\nUp and Down\n\n\n\nThis is a good one.\n\n\n\n\n\nOl’ Jimbob is back and his code looks atrocious. Sure, his code works,\nbut it is very hard to read and is unnecessarily complex. Your job is to\nchange only Jimbob’s if conditions so that it makes more sense. Also,\ntry and figure out why Jimbob’s code works.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#include &lt;iostream&gt;\nusing namespace std;\n// this program takes 3 side lengths of a triangle and outputs a message\n// saying what type of triangle it is\nint main() {\n    cout &lt;&lt; \"Input 3 side lengths.\" &lt;&lt; endl;\n    int s1, s2, s3;\n    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;\n    if(((s1!=s2)!=(s2==s3))+((s1!=s3)!=(s1==s2))==2) {\n        cout &lt;&lt; \"The triangle is scalene.\";\n    }\n    else if((s1==s2)+(s2==s3)+(s1==s3)==1) {\n        cout &lt;&lt; \"The triangle is isosceles.\";\n    }\n    else {\n        cout &lt;&lt; \"The triangle is equilateral.\";\n    }\n    return 0;\n}\n\n\n\n\n\n\n\nFurther Reading for If Statements\n\n\nXOR\n\nThe XOR operator (\\^) is an operator that can be used like a logical\noperator.\n\n\nThis operator is able to take two boolean values and return true if\nonly one of the given values is true. If both or neither boolean values\nare true, it will return false. The reason why this operator is not a\nlogical operator is because it is a bitwise operator and could be used\nin scenarios beyond the scope of this chapter.\n\n\n\n\n\n\n\n\nExamples\nResults\n\n\n\n\n\ntrue \\^ true\n\n\ntrue \\^ false\nfalse \\^ true\n\n\nfalse \\^ false\nfalse\n\n\ntrue\ntrue\n\n\n\n\n\nComparing Characters\n\nEach character has its own numerical representation. When a variable\nstores a character, the variable is holding a number that corresponds to\nthat character. The characters and their corresponding number follows\nthe American Standard Code for Information Interchange (ASCII). In\nC++, each character can be referred to by using either the character\nitself enclosed by single quotation marks (\\'A\\') or their numerical\nrepresentation (65).\n\n\nA table displaying each character’s corresponding number can be obtained\nhere:\n\n\nIn the code below, the value of the character variable is set to ‘A’\n\nchar var = 65;\n\nWhen a character is being used with a relational operator in C++, the\nnumerical representation of that character is being compared and not\nthe character itself. So the following two excerpts of code perform the same task:\n\nchar c = 111;\n\ncout &lt;&lt; (c &gt; 'a');\nchar c = ‘o’;\n\ncout &lt;&lt; (c &gt; 97);\n\nThis is how C++ uses characters with relational operators.\n\n\n\nSwitch Statements\n\nSwitch Statements are alternative ways of control flow that is used\nwhenever an if structure would lead to many else if statements in code.\nThey work in the same way as if statements but are more concise when the\nnumber of conditions is large. It is used over an if structure whenever\nthe condition is whether or not a variable is equal to a certain\nvalue.\n\n\nA switch statement resembles the following:\n\nswitch (variable name) {\ncase possibleValue:\n    // your code\n    break;\ncase possibleValue2:\n    // your code\n    break;\n// the number of cases may continue\ndefault:\n    // your code\n}\n\nIn a switch statement, the default case acts as an else statement in\nan if structure. The purpose of the break statements will be explained\nin the following chapter. Switch statements are not required as they do\nthe same task as if structures.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"What's your mark?\" &lt;&lt; endl; // asks for a mark\n    char mark;              // char variable to store mark\n    cin &gt;&gt; mark;\n    switch(mark){           // checks value of mark\n    case 'A' :              // checks if mark == 'A'\n        cout &lt;&lt; \"Amazing!\"; // output if mark == 'A'\n        break;\n    case 'B' :              // checks if mark == 'B'\n        cout &lt;&lt; \"Nice nice.\";\n        break;\n    case 'C' :              // checks if mark == 'C'\n        cout &lt;&lt; \"You're getting there.\";\n        break;\n    case 'D' :\n        cout &lt;&lt; \"Try Harder.\";\n        break;\n    default :\n        // default statement if all previous return false\n        cout &lt;&lt; \"That's not a rank!\";\n    }\n    return 0;\n}\n\nSample Case:\n\nWhat’s your mark?\nA\nAmazing!\n\n\n\nSample Case 2:\n\nWhat’s your mark?\nD\nTry Harder.\n\n\n\nSample Case 3:\n\nWhat’s your mark?\nR\nThat’s not a rank!\n\n\n\n\n" },"lessons-beginners-loop-structures":{ url:"/lessons/beginners/loop-structures",title:"Loop Structures",subclub:"beginners",content:"\n\n\nGoal: To be able to implement While and For loops into code\n\n\n\n\nIntroduction\n\n\nA loop is a mean of control flow where certain commands are repeated\nmultiple times. They are used whenever similar actions are performed\nnumerous times. The number of times and when to stop repeating can be\ncontrolled and can differ based on the values of variables.\n\n\n\n\nWhile Loops\n\n\nThe while loop is the most basic type of loop structure in C++. They are\nformatted as follows:\n\nwhile (condition) {\n    // commands to loop if condition is true\n}\n\n\n\n\nOnce the program enters a while loop, it will check the condition stated\nin parenthesis. If the condition results to true, then everything in\nthe braces will be executed. Once everything in the braces is executed,\nthe program will move back to the beginning of the loop structure and\ncheck whether the condition still results to true or not. If the\ncondition still results true, then the whole looping process repeats. If\nthe condition results false, then the program will move down to any\ncommands after the while loop.\n\n\nAs long as the condition in parenthesis remains true, the program will\nendlessly loop inside of the while loop.\n\n\nSample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int counter = 0;\n    // if condition returns false, go to line 10\n    while (counter &lt; 3) {   // checks if the counter is below 3\n        counter++;          // adds one to the counter\n        cout &lt;&lt; counter &lt;&lt; endl;\n    }                       // after looping, it goes back to line 6\n    cout &lt;&lt; \"End\";\n    return 0;\n}\n\nIn the previous example, a counter variable was initialized and the\nprogram will continue to loop and increase the counter by 1 when the\ncounter is less than 3. Once the condition results false, it moves out\nof the while loop to the remaining code on Line 10.\n\n\nApart from having the condition at the beginning of a while loop, a\ncommand known as break tells the program to immediately exit the\ncurrent loop it is in. Break can be combined with an if statement so\nthat the program can leave the loop if the condition in the if statement\nis met.\n\n\nThe following code will have the same outputs as the code above:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int counter = 0;         // initializes counter variable\n    while (true) {           // condition will always return true\n        if (counter &gt;= 3) {  // exit condition\n            break;           // goes immediately to line 13\n        }\n        counter++;           // adds one to the counter\n        cout &lt;&lt; counter &lt;&lt; endl;\n    }                        // goes back to line 6\n    cout &lt;&lt; \"End\";\n    return 0;\n}\n\n\n\nFor Loops\n\n\nIn the examples above, a counter variable was manually made in order to\nuse the while loop. Typically, while loops are not used when the program\nloops a known number of times. For loops are also known as counted\nloops because it is made to have a counter variable. The format of\nthe for loop resembles the following.\n\nfor (int counterVariable; condition; changetoCounter) {\n    // commands while condition above is true\n}\n\nThe section in parentheses are divided into three groups\n\n\n\n\nThe first part initializes the counter variable to be used for the\nentire loop structure\n\n\n\nVariable names for counters are often i or j\n\n\n\n\n\nThe second part is the condition that usually includes the counter\nvariable.\n\n\n\nIf the condition results true, the program goes through the for loop\n\n\nIf the condition results false, the program will exit the for loop\n\n\n\n\n\nThe third part is the changes the counter variable goes through each\ntime the program loops\n\n\n\n\n\n\n\nNote\n\n\nNotice how each section is divided by semicolons.\n\n\n\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // set counter, i, to 3\n    for (int i = 3; i &gt; 0; i--) { // if i &lt;= 0, go to line 9\n        cout &lt;&lt; i &lt;&lt; endl;\n    }   // goes back to line 6 and subtracts 1 to i\n    cout &lt;&lt; \"End\";\n}\n\nOutput:\n\n\n\n3\n2\n1\nEnd\n\n\n\nOn line 6, a counter was created and set to 3 to start off. The program\ncontinued to loop, and the counter kept decrementing by one until the\ncounter was 0, and the condition results false.\n\n\n\n\nBrief Introduction to Scope\n\n\nIn C++, scope refers to a specific region in code that are surrounded\nby braces. For example, the main function is its own scope and it can\nnest smaller scopes if it had loop or if structures in it. Braces act as\nbarriers for variables. Chapter 8 warned how a variable cannot be\ninitialized in an if structure and used outside of the if structure.\nThis is because any initialized variable cannot be used outside of the\nscope it was initialized in.\n\n\nWhen a variable is initialized in a smaller scope (Ex: a loop), a place\nin memory is made and no other variable can be created with the same\nname as that variable. That variable is able to be accessed within\nsmaller scopes and can be used any time so long as the program is still\nat the scope the variable was initialized in. When the program leaves\nthat scope (Ex: when it leaves a loop), all variables initialized\ninside that scope are destroyed and space in the memory is freed. This\nmeans that a variable initialized in the smaller scope no longer\nexists. This also means that another variable with the exact same name\ncan be made.\n\n\nThis is why properly indenting code is important. Indentations show\nwhere exactly variables are able to be used and when they will be\ndestroyed. It also shows how each scope nests within larger scopes. The\nnumber of indents a command has represents the number of nested scopes\nthere are.\n\n\nOn the example code on the next page, there are two different instances\nwhere variable i is initialized. However, since they were not declared\nin the same scope, the two variables did not co-exist. Instead, the\nsecond i variable was initialized when the first i variable was\nalready destroyed.\n\n\nDemonstration of Scopes:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include &lt;iostream&gt;\nusing namespace std;\n// pay attention to all the indents\nint main() {\n    // variable declared in the scope of the main fcn\n    int var = 0;\n    // counter declared in the scope of the for loop\n    for (int i = 0; i &lt; 3; i++) {\n        cout &lt;&lt; i &lt;&lt; endl;\n        var++;\n    }\n    // i no longer exists, but var still exists\n    for (int i = 0; i &lt; 3; i++) {\n        // i now exists again, since it was reinitialized\n        cout &lt;&lt; i &lt;&lt; endl;\n        var++;\n    }\n    // i no longer exists... again\n    cout &lt;&lt; var;   // outputs total number of loops\n    return 0;\n}\n// var does not exist anymore\n\nOutput:\n\n\n\n0\n1\n2\n0\n1\n2\n6\n\n\n\n\n\nIn Summary\n\n\n\n\nWhile loops and for loops are used to have the program repeat the same\ncommands multiple times\n\n\nThe program will leave the while loop once the condition in the while\nloop results false\n\n\nFor loops include a counter variable as well as an if condition\n\n\nA for loop is for counted loops and a while loop is for non-counted\nloops\n\n\nBreak can be used on both loops to end the looping procedure\n\n\nVariables cannot be used outside of the scope the variable has been\ninitialized in\n\n\n\n\n\n\nContest Questions\n\n\n\n\nExact Divisors\n\n\nTimes Tables\n\n\nRSA Numbers\n\n\nSleep Cycle\n\n\n\nMore difficult, great question\n\n\n\n\n\n\n\n\n\n\nFurther Reading on Loops Structures\n\n\nDo-While Loops\n\nDo-while loops are modified while loops. They makes sure that the\nprogram runs everything in the loop structure at least once. The\ncondition for looping is checked at the very end of the loop structure\nand not at the beginning. The syntax of the do-while loop is the\nfollowing:\n\n1\n2\n3\ndo{\n    //code to be executed atleast once\n} while (condition);\n\n\nExtra Information on For Loops and Nested Loops\n\nNothing between the parenthesis in a for loop are required for a for\nloop to run. (except the semicolons) The for loop does not need an exit\ncondition or a variable initialization. This allows the for loop to be\nmore flexible as a counter variable can be initialized and used inside\nand outside of the scope of the for loop.\n\n\nWhen a loop is found inside of another loop, the inner loop is known as\na nested loop. Nesting loops are commonly used in code. When the\nbreak command is used inside of a nested loop, the program will exit\nthe innermost loop that it is currently in. That means, the program did\nnot exit the larger loop yet and will require a separate break\nstatement.\n\n\nAn demonstration of how for loops can be used and how nested loops works\nare shown below.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 0;    // counter variable pre-initialized\n    for (; i &lt; 3;) {\n    // this for loop can be replaced with a while loop\n    // since there is not increase nor initialization\n        if (i % 2 == 0) {\n            // nests another loop if line 9 results true\n            for (int j = 0;; j++) {      // no condition\n                if (j == 3){\n                    break;              //go to line 16\n                }\n                cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;\n            }\n        }\n        i++; // counters can be modified within the loop\n    }\n    // variable i can still be used because it was not\n    // initialized inside of the for loop\n    return 0;\n}\n\nOutput:\n\n\n\n0 0\n0 1\n0 2\n2 0\n2 1\n2 2\n\n\n\n\n" },"lessons-beginners-arrays":{ url:"/lessons/beginners/arrays",title:"Arrays",subclub:"beginners",content:"\nIntroduction\n\n\n\n\n\n\n\nConsider having a program that stores the price of various items in a\nstore. This program could have an integer variable storing the price for\neach item in the store. Business is bad and the store is forced to raise\nthe price of every item in the store by $1. If each price were its own\ninteger variable, raising the price of every item would be messy. If\neach price were its own variable, it would take so many lines of code to\nraise each price by\none.\n\n\nPutting the store scenario aside, there are many instances where large\namounts of variables must be changed, or even compared. Having a\nseparate name for each variable would simply be too inconvenient for the\nuser and the coder.\n\n\nArrays are the solution to having large amounts of similar variables. An\narray is a data structure that collects and organizes variables under\none name.\n\n\n\n\nStructure of an Array\n\n\nTable 1. Structure of a 6-Element Integer Array\n\n\n\n\n\n\n\n\n\n\n\nData Value\n24\n35\n46\n57\n68\n79\n\n\nIndex\n0\n1\n2\n3\n4\n5\n\n\n\n\nAn array is a container that stores variables of the same data type.\nEach individual variable in an array is called an element. Each\nelement in an array is stored, organized, and numbered with a value\ncalled an index. An element in an array can be accessed by using the\nindex that it is assigned. The very first element of an array will\nalways be given the index of 0. The rest of the elements are simply\nnumbered in order. For example, an element of index 2 would be the third\nelement of the array.\n\n\nTable 2. Array that Stores 50 Prices\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrice of item ($)\n3\n5\n6\n9\n12\n42\n&hellip;\n9\n\n\n\nItem number (index)\n\n0\n1\n2\n3\n4\n5\n&hellip;\n50\n\n\n\n\nUsing the store scenario, an array of 50 prices would not only organize\nall the values properly, but would also make the prices much easier to\nwork with for a computer.\nWhen using arrays, the number of elements that are in an array will\nalways remain constant. This means that an element cannot be added or\nremoved from an array.\n\n\n\n\nArray Initialization and Assignments\n\n\nOn C++, an array initialization should be formatted like the following:\n\nDataType ArrayName[Size];\n\nThis statement will tell the computer to allocate memory for Size\nvariables of DataType type. A variable can be placed where the size of\nthe array should be (Integer variable that is). Notice how square\nbrackets ([ ]) are used when working with arrays.\n\n\nIn order to access the value that an element in an array is storing, the\nindex of that variable must be known. In code, VariableName[n] would\nreturn the variable in the array with index n. VariableName[n] refers\nto a variable and operates like any other variable. For example,\nVariableName[0] and VariableName[1] refer to two completely different\nvariables and can be used as two separate variables. Each element of the\narray can be worked with individually.\n\n\nNote: Initializing an array of size n will have its last element’s\nindex be n-1. For example, initializing an array of size 50 will create\n50 elements numbered from 0 to 49. There is no element with index 50.\n\n\nSince the index of an array increments by one when going through each\nelement, arrays are often used together with for loops where the counter\nvariable acts as the index of the element to be looked at.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#include &lt;iostream&gt;\n// Makes an array storing the first 5 even number\nusing namespace std;\nint main() {\n    // creates integer array with 5 elements in it\n    int numbers[5]; // size 5\n    // for loop to store a value in each element\n    for (int i = 0; i &lt; 5; i++) {\n        // gives each element in the array a value\n        numbers[i] = i * 2;\n    }\n    cout &lt;&lt; \"Array Contains: \" &lt;&lt; endl;\n    // for loop to access the value of every element\n    for (int i = 0; i &lt; 5; i++) {\n        // outputs value of each the current element\n        cout &lt;&lt; numbers[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n\nOutput:\n\n\n\nArray Contains:\n0 2 4 6 8\n\n\n\nNotice how the counter variable i is also being used as an index for\nthe array. A for loop is the ideal method for reading through all\nelements in an array.\n\n\n\n\nPractice Questions\n\n\n\n\nRagaman\n\n\nProblem-setting Pandemonium\n\n\n\n\n" },"lessons-beginners-multidimensional-arrays":{ url:"/lessons/beginners/multidimensional-arrays",title:"Multidimensional Arrays",subclub:"beginners",content:"\nIntroduction\n\n\n\n\n\n\n\nAn array can be visualized as a row of elements where each element has\nits own column number (index). A regular array is usually known as a\none-dimensional array because every element can be placed in one row.\n\n\n\n\n\n\n\nA multidimensional array is simply an array of arrays. A\nmultidimensional array has elements with more than one index. A\ntwo-dimensional array can be visualized as rows of arrays stacked\ntogether in order to create a grid. Therefore, each element in that\narray will have both a row number and a column number. Each pair of\ncoordinates (row, column) will refer to a unique element in the array.\nWhat makes a one-dimensional array different than a multidimensional\narray is the number of indexes that each element has.\n\n\nTwo-dimensional arrays (arrays with 2 indexes) are often used whenever\nvariables must be organized into a grid. That way, a computer can easily\nlook through an entire row/column in a grid. Three-dimensional arrays\ncan be visualized as a cube where each index corresponds to a different\ndimension of the cube.\n\n\nIn C++, each square bracket ([ ]) corresponds to a separate dimension of\nan array. For example, a two-dimensional array will have two sets of\nsquare brackets. When initializing an array, the size of each dimension\nof the array must be given.\n\narrayType arrayName [size1] [size2];\n\nWhen accessing an element in a multidimensional array, the index of each\ndimension must be known. Each set of indexes refers to a unique element\nin an array.\n\narrayName[index1][index2]\n\n\n\n\nNote\n\n\nNo set of square brackets can be left blank when accessing an\nelement in an array.\n\n\n\n\n\nExample code of a 2-dimensional array:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    // the purpose of this code is to show a 4 by 4 multiplication table\n    int len = 4;            // len is the size of each dimension of the array\n    int grid[len][len];     // grid is a len by len 2-dimensional array\n    for (int i = 0; i &lt; len; i++) {         // i represents the row number\n        for (int j = 0; j &lt; len; j++) {     // j represents the col number\n            grid[i][j] = (i + 1) * (j + 1); // assigns a value to each element\n        }\n    }\n    cout &lt;&lt; \"Look at this Cool Multiplication Table\" &lt;&lt; endl;\n    // looks at every column in each row and outputs element in array\n    for (int i = 0; i &lt; len; i++) {\n        for (int j = 0;j &lt; len; j++) {\n            cout &lt;&lt; grid[i][j] &lt;&lt; \" \";  // outputs the value of the element\n        }\n        cout &lt;&lt; endl;                   // skips to new line when outputting\n    }\n    return 0;\n}\n\nOutput:\n\n\n\nLook at this Cool Multiplication Table\n1 2 3 4\n2 4 6 8\n3 6 9 12\n4 8 12 16\n\n\n\n\n\nIn Summary:\n\n\n\n\nArrays are used to organize multiple variables of the same type\n\n\nEach variable in an array is called an element\n\n\nEach element is ordered and given an index\n\n\nThe first element of an array always has an index of 0\n\n\nThe size of an array will always remain constant\n\n\nMultidimensional arrays are arrays of arrays, and each element in a\nmultidimensional array has more than one index\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nConnect 4\n\n\nMagic Squares\n\n\n\n\n" },"lessons-beginners-strings":{ url:"/lessons/beginners/strings",title:"Strings",subclub:"beginners",content:"\n\n\nGoal: To understand how to initialize and manipulate text strings.\n\n\n\n\nIntroduction\n\n\nIndividual variable types can be combined and be used as one unit. This\nunit is known as a container. A string is a type of container as it is\na chain of characters. Words, and full sentences are examples of\nstrings. This lesson will focus on using the string container offered in\nthe &lt;string&gt; library.\n\n\nIn order to use standard strings from the string library, an include\nstatement must be made at the beginning of the C++ file. The string\nlibrary includes not only the container itself, but member functions\nthat are specifically for that container. Member functions can perform\nmany operations including string manipulation. A detailed list of the\nstring library can be found\nhere.\n\n\n\n\nVariable Initialization and Input\n\n\nOnce the string library has been included, a string can be initialized\nlike any other variable. When a string is initialized, the string\nitself will always start off empty. Therefore, outputting the string\nimmediately after initializing will simply output an empty string (\"\")\nand not garbage.\n\n\nWhen std::cin from the &lt;iostream&gt; library is used to get a value for a\nstring, the console will only accept all characters until it reaches\nwhitespace. This means cin cannot be used to store an input that is a\nsentence with spaces. If inputs are supposed to have spaces, another\nfunction is used. getline is a function that is used to get an\nentire line of input and store it into a string. It is formatted like\nthe following:\n\ngetline(cin, variableName);\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main() {\n    string name;       // initializes string\n    cout &lt;&lt; \"What's your name?\" &lt;&lt; endl;\n    getline(cin,name); // stores full name\n    cout &lt;&lt; \"Hi \" &lt;&lt; name &lt;&lt; ”!”;\n    return 0;\n}\n\nSample Run:\n\n\n\n&gt;&gt;&gt; What’s your name?\nHerp da Derp\n&gt;&gt;&gt; Hi Herp da Derp!\n\n\n\n\n\n\nNote\n\n\nIf cin was used before getline, cin.ignore() should be placed\nbefore getline(). cin.ignore() is a function that clears any inputs\nthat are not stored in a variable and is required for getline() to work\nproperly.\n\n\n\n\n\n\n\nUsing Member Functions and String Manipulation\n\n\nAs for all libraries for C++, a list of all member functions can be\nfound online. For a string, every function is made to manipulate/extract\ninformation from a string. Therefore, most of the functions in the\nstring are formatted as follows:\n\nstringName.memberFunction(parameters) // notice the dot\n\nFor example, to find the length of a string, strName.length() will\nreturn an integer that represents the length of the string with the\nname, strName.\n\n\nA string can be assigned text surrounded by quotation marks with an\nequal sign (=).\n\n\nString concatenation is the appending of two or more strings. Strings\ncan be added with text or other strings using the + operator. Since the\n+ operator can be used, the += operator can be used as well.\n\n\nExample Code\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\nint main() {\n    string str1 = \"abc\", str2 = \"efg\", str3; // initialized 3 strings\n    cout &lt;&lt; \"str3 is \" &lt;&lt; str3.length() &lt;&lt; \" characters long.\" &lt;&lt; endl;\n    str3 = str2;          // assigns a value to str3\n    cout &lt;&lt; \"str3 is \" &lt;&lt; str3.length() &lt;&lt; \" characters long.\" &lt;&lt; endl;\n    str3 += \"d\" + str1;     // concatenates str3 with \"d\" and str1\n    cout &lt;&lt; \"str3 is \" &lt;&lt; str3.length() &lt;&lt; \" characters long.\" &lt;&lt; endl;\n    return 0;\n}\n\nOutput:\n\n\n\nstr3 is 0 characters long.\nstr3 is 3 characters long.\nstr3 is 7 characters long.\n\n\n\nThe plus symbol (+) is the only arithmetic operator that can be used\nwith a string. Do not try and subtract strings using the - operator.\nLikewise, = and += are the only assignment operators that can be used\nfor strings.\n\n\n\n\n\nNote\n\n\nDo not add two string literals (text surrounded by quotation\nmarks) together.\n\n\n\n\nstr += \"abc\" + \"def\"; // \"abc\" can’t add with \"def\"\n\nThe above code will result in an error because the computer is trying to\nadd two string literals. This could be fixed by altering the code like:\n\n|str = (str + \"abc\") + \"def\"; // str adds with \"abc\", then with \"def\"\n\nThat way, a string will always add with a string literal and two\nstring literals will never add with each other. The reason why strings\nare able to add with string literals are beyond the scope of this\ncourse. Just make sure to not add string literals together.\n\n\n\n\nCharacter Manipulation\n\n\nSince a string is simply a sequence of characters, each character acts\nas its own variable and can be accessed and manipulated individually.\nAccessing a specific character in a string is formatted as follows,\nstr[n] where the character returned will be the nth character in the\nstring.\n\n\n\n\n\n\n\nEach character in a string has an index. All the characters in a\nstring are numbered in order starting with index 0. For example,\nstr[1] will give the second character in a string. Indexes are typically\nused with for loops in order to access every character in a string.\n\n\n\n\n\nNote\n\n\nBe Careful! str.length() returns the length of a string, but the\nhighest index in that string will always be one less than the length of\nthe string.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n// This code outputs the reverse of a word\nusing namespace std;\nint main() {\n    string str;             // initializes string\n    cin &gt;&gt; str;             // gets input (no sentences)\n    string reverseStr;      // string to store the reverse of str\n    // i is initialized as the highest index of str\n    for (int i = str.length() - 1; i &gt;= 0; i--) { // index decreases by 1 each loop\n        // in this context, i acts as an index number\n        reverseStr += str[i]; // string is made by repeated concatenation\n    }\n    cout &lt;&lt; str &lt;&lt; \" backwards is \" &lt;&lt; reverseStr; // outputs reverse str\n    return 0;\n}\n\nSample Run:\n\n\n\nKappa\n&gt;&gt;&gt; Kappa backwards is appaK\n\n\n\n\n\nASCII\n\n\nASCII stands for American Standard Code for Information Interchange.\nASCII ensures that every character is paired with a numerical value.\nEach character in a string is stored as that numerical value and every\ncharacter can be referred to be either the character itself, or its\nnumerical representation.\n\n\nASCII is further explained in Chapter 7.\n\n\nFor a list of all characters and their numerical counterparts, click\nhere.\n\n\n\n\nIn Summary\n\n\n\n\nContainers are used to organize and store various variable types at once\n\n\nA string is a type of container that stores a sequence of characters\n\n\nStandard strings are found in the &lt;string&gt; library\n\n\nCommands from a library are called member functions\n\n\ngetline() is used to get inputs that includes spaces\n\n\nMember functions are formatted as str.memberFunction(parameters)\n\n\nStrings can be concatenated with other strings or characters.\n\n\nEach individual character can be accessed with str[]\n\n\nIndex refers to where a character is in a string\n\n\nThe first character in a string is always index 0.\n\n\nASCII is used to pair every character with a numerical value.\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nEnglish or French\n\n\n\nMy personal favourite\n\n\n\n\n\nHidden Palindrome\n\n\nHidden Geography\n\n\nSimple Encryption\n\n\n\nDon’t be fooled, this is the hardest question out all of the practice\nquestions\n\n\n\n\n\n\n\n" },"lessons-beginners-other-containers":{ url:"/lessons/beginners/other-containers",title:"Other Containers",subclub:"beginners",content:"\nVectors are containers used to store an unknown number of elements. In\nother languages, vectors are also known as flexible arrays. Vectors\nallow elements to be added or removed at any given time. This means that\nthe size of a vector can change. Elements in a vector have indexes and\ncan be accessed like an array. Vectors can be used if the &lt;vector&gt;\nlibrary is included. Typically, arrays are used over vectors whenever\npossible. Vectors are only used when the size of an array will change\nfrequently. Info on vectors and their member functions can be found\nhere:\n\n\nExample Code:\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n#include &lt;iostream&gt; // cin, cout\n#include &lt;vector&gt; // vector container\nusing namespace std;\nint main()\\{\nvector&lt;int&gt; vec; // initializes a vector of integers\nint temp; // used for vector.push_back\ncout&lt;&lt;\"Add some numbers to the vector\"\ncout&lt;&lt;\"Enter 0 to stop entering numbers\"&lt;&lt;endl;\nwhile(true)\\{\ncin\">[endl;\ncout&lt;&lt;\"Enter 0 to stop entering numbers\"&lt;&lt;endl;\nwhile(true)\\{\ncin]temp; // gets user input\nif (temp==0)\\{ // if 0 is inputted, the loop breaks\nbreak;\n}\nvec.push_back(temp); //adds an element to the end of the vector\n}\n//vec.size returns the size of the vector\ncout&lt;&lt;\"Your vector has \"&lt;&lt;vec.size()&lt;&lt;\" elements: \";\n// lists all elements in the vector\nfor(int i=0;i&lt;vec.size();i++)\\{\ncout&lt;&lt;vec[i]&lt;&lt;\" \"; //elements in a vector have indexes too.\n}\nreturn 0;\n}\n\n\n\n\nSample run:\n\n\n\n\n\n\n\n\nAdd some numbers to the vector\n\n\nEnter 0 to stop entering numbers\n\n\n2 3 4 5 6 0\n\n\nYou vector has 5 elements: 2 3 4 5 6\n\n\n\n\n\nQueues (First-in, First-out)\n\n\nQueues are containers used to store an unknown number of elements. The\nfirst element that is added to a queue will always be the first\nelement to be removed from a queue. The last element that is added to\na queue will be the last element to be removed. Queues do not allow\nevery element to be accessed, only the first and the last element in a\nqueue. They are often used to simulate queues and lines in real life.\nQueues can be used it the &lt;queue&gt; library is included.\n\n\nMore info on queues and their member functions can be found\nhere:\n\n\nExample Code:\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n#include &lt;iostream&gt; // cin, cout\n#include &lt;queue&gt; // queue container\nusing namespace std;\nint main()\\{\nqueue&lt;int&gt; line; // initializes queue of integers\nint temp; // variable for user input\ncout&lt;&lt;\"How many numbers are in the queue?\"\ncin \">[endl;\ncin ] temp;\nfor(int i=0;i&lt;temp;i)\\{ +\nline.push(i); _// adds an element to the back of the queue_ +\n} +\ncout&lt;&lt;\"How many numbers will leave the queue?\"&lt;&lt;endl; +\ncin &gt;&gt;temp; +\nfor(int i=0;i&lt;temp;i)\\{\nline.pop(); // removes an element from the front of the queue\n}\n// line.size returns the size of the queue\ncout&lt;&lt;\"The queue has \"&lt;&lt;line.size()&lt;&lt;\" elements.\"&lt;&lt;endl;\n// line.front and line.back returns the first and last element\ncout&lt;&lt;\"The first element is \"&lt;&lt;line.front()&lt;&lt;endl;\ncout&lt;&lt;\"The last element is \"&lt;&lt;line.back()&lt;&lt;endl;\nreturn 0;\n}\n\n\n\n\nSample Run:\n\n\n\n\n\n\n\n\nHow many numbers are in the queue?\n\n\n8\n\n\nHow many numbers will leave the queue?\n\n\n5\n\n\nThe queue has 3 elements\n\n\nThe first element is 5\n\n\nThe last element is 7\n\n\n\n\n\nStacks (Last-in, First-out)\n\n\nStacks are containers used to store an unknown number of elements. The\nfirst element that is added to a stack will be the last element to\nbe removed from a stack, and the last element that is added to a stack\nwill be the first element to be removed. Only the top element in a\nstack can be accessed. Stacks can be used if the &lt;stack&gt; library is\nincluded. More info on stacks and their member functions can be found\nhere:\n\n\nExample Code:\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n24\n\n\n25\n\n\n26\n\n#include &lt;iostream&gt; // cin, cout\n#include &lt;stack&gt; // stack container\n\nusing namespace std;\nint main()\\{\nstack&lt;int&gt; myStack; //initializes a stack\nint temp; // variable for user input\ncout &lt;&lt; \"Type in a number to add it to the stack.\" &lt;&lt; endl;\ncout &lt;&lt; \"Press 0 to pop an element or -1 to exit.\" &lt;&lt; endl;\nwhile(true)\\{\ncin &gt;&gt; temp; // gets user input\nif(temp==-1)\\{\nbreak; // exit user input\n}\nelse if(temp==0)\\{\nmyStack.pop(); // removes the top element of a stack\n}\nelse\\{\nmyStack.push(temp); // adds element to the top of the stack\n}\n}\ncout &lt;&lt; \"Your stack has \" &lt;&lt; myStack.size() &lt;&lt; \" elements.\" &lt;&lt; endl;\n// myStack.top returns the element on the top of the stack\ncout &lt;&lt; \"The element on the top of the stack is \" &lt;&lt; myStack.top();\nreturn 0;\n}\n\n\n\n\nSample Run:\n\n\n\n\n\n\n\n\nType in a number to add it to the stack.\n\n\nPress 0 to pop an element or -1 to exit.\n\n\n3 4 6 0 2 3 0 0 0 8 -1\n\n\nYour stack has 2 elements.\n\n\nThe element on the top of the stack is 8\n\n\n\n\n\nPair\n\n\nPairs are used to store two data values. They are often used in\nconjunction with other containers such as arrays or vectors. A frequent\nscenario that uses pairs is coordinates. In that scenario, an array of\ncoordinates can be made with pairs. Pairs can be used if the &lt;utility&gt;\nlibrary is included. More info on pairs and their member functions can\nbe found here:\n\n\nExample Code:\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n\n24\n\n\n25\n\n\n26\n\n\n27\n\n\n28\n\n\n29\n\n\n30\n\n\n#include &lt;iostream&gt; // cin, cout\n#include &lt;utility&gt; // stack container\n#include &lt;string&gt; // string container\nusing namespace std;\nint main()\\{\nint numShows; // variable that stores the number of shows\ncout &lt;&lt; \"How many shows are there? \";\ncin &gt;&gt; numShows;\n// Makes an array of pairs. Each pair has a string and an integer\n// string is the first data value of pair, integer is the second\npair &lt;string,int&gt; shows[numShows];\nfor(int i=0;i&lt;numShows;i++)\\{ // for loop for user input\ncout &lt;&lt; \"What&#8217;s the show’s name: \";\ncin.ignore(); // always put this before getline()\n_// goes to the ith pair of the array, and stores a string to _\n\n\n// the \"first\" variable of that pair\ngetline(cin,shows[i].first);\ncout &lt;&lt; \"What&#8217;s its rating: \";\n\n\n// stores integer in the second variable of the ith pair\ncin &gt;&gt; shows[i].second;\n\n\n}\nint x; // variable to store the show to be looked at\ncout &lt;&lt; \"What show do you want to know about?\";\ncin &gt;&gt; x;\n_// accesses the value of the (x-1)th pair. Remember how arrays are _\n\n\n// indexed starting with 0\ncout &lt;&lt; shows[x-1].first&lt;&lt;\" has a rating of \"&lt;&lt; shows[x-1].second;\nreturn 0;\n}\n\n\n\n\n\nSample Run:\n\n\n\n\n\n\n\n\nHow many shows are there? 3\n\n\nWhat’s the show’s name: Bobby the Construction Worker\n\n\nWhat’s its rating: 3\n\n\nWhat’s the show’s name: Doris the Expeditioner\n\n\nWhat’s its rating: 9\n\n\nWhat’s the show’s name: The Magic Garbage Truck\n\n\nWhat’s its rating: 6\n\n\nWhat show do you want to know about? 2\n\n\nDoris the Expeditioner has a rating of 9\n\n\n\n\n\nMaps\n\n\nMaps are containers that store corresponding data values. Instead of\nusing an index to refer to a specific data value, it uses another data\nvalue. Maps are used whenever a value corresponds to another value. For\nexample, Roman Numerals would use maps because it has a\ncharacter-integer correspondence (V with 5). That being said, a data\nvalue cannot correspond to two or more other data values. Also, if a\nmap receives an index that doesn&#8217;t have a corresponding data value, it\nreturns 0 if the corresponding data value should be a an integer or an\nempty string (“”) if the data value should be a string. Maps can be\nused in a code file if the &lt;map&gt; library is included. More info on\nmaps and their member functions can be found\nhere.\n\n\nExample Code:\n\n\n\n\n\n\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n12\n\n\n13\n\n\n14\n\n\n15\n\n\n16\n\n\n17\n\n\n18\n\n\n19\n\n\n20\n\n\n21\n\n\n22\n\n\n23\n\n#include &lt;iostream&gt; // cin, cout\n#include &lt;map&gt; // map container\n#include &lt;string&gt; // string container\n\nusing namespace std;\n//map pairs each Canadian province with its two letter abbreviation\nint main()\\{\n// initializes a map where a string corresponds to another string\nmap&lt;string,string&gt; provinces;\nprovinces[\"AB\"]=\"Alberta\"; // gives value for each element\nprovinces[\"BC\"]=\"British Columbia\"; // notice how this map has no\nsize\nprovinces[\"MB\"]=\"Manitoba\"; // this list could be gigantic\nprovinces[\"NB\"]=\"New Brunswick\"; // the list could just continue\nprovinces[\"PE\"]=\"PEI\"; // assuming we have much more provinces\n//&#8230;&#8203; This goes on for the remaining 8 provinces/territories\n\ncout &lt;&lt; \"Hey! Which province/territory do you live in? \";\nstring abbreviation; // string for user input\ncin &gt;&gt; abbreviation;\n//province[s] would return the string that corresponds with string s\ncout &lt;&lt; \"WOW! You live in \" &lt;&lt; provinces[abbreviation] &lt;&lt; \"?!?!\";\nreturn 0;\n}\n\n\n\n\nSample Run 1:\n\n\n\n\n\n\n\n\nHey! Which province/territory do you live in? MB\n\n\nWOW! You live in Manitoba?!?!\n\n\n\n\n\nSample Run 2:\n\n\n\n\n\n\n\n\nHey! Which province/territory do you live in? XX\n\n\nWOW! You live in ?!?!\n\n\n\n\n\nIn Summary\n\n\n\n\nA vector is a container that acts like an array, but can change size\n\n\nA queue is a container with a first-in, first-out (FIFO) policy when\nadding and removing elements\n\n\nA stack is a container with a last-in, first out (LIFO) policy when\nadding and removing elements\n\n\nA pair is a container that stores two data values\n\n\nA map is a container that gives a one to one correspondence between two\ndata values.\nPractice Questions\n\n\nThe Geneva Confection\n\n\n" },"lessons-beginners-functions":{ url:"/lessons/beginners/functions",title:"Functions",subclub:"beginners",content:"\n\n\nGoal: To be able to create and call functions\n\n\n\n\nWhat is a Function?\n\n\nA function in computer science works exactly like a function in\nmathematics. The purpose of a function is to take data inputs,\nmanipulate them, and return an output. Functions can have multiple\ninputs, but can only return *one output. *\n\n\nFunctions have been used throughout the course. Whenever a function is\nneeded, a function call is placed in the code. An example of a\nfunction is the square root (sqrt()) function. This function will always\nreturn the positive square root of a given value.\n\n\n\n\n\n\n\nAll functions will have a function name and parameters. In the square\nroot function, “sqrt” would be the function name. Functions can only be\ncalled when the name of the function is known. When using the square\nroot function, the value to be square rooted is the input. This input\nvalue is called a parameter. Parameters are always placed between the\nparenthesis in the function. Notice how the square root function takes\nan input, and only returns one output. This output is called a return\nvalue and is found in most functions.\n\n\nSquare root is one of many common functions that are used in C++. A list\nof commonly used functions can be found\nhere.\n\n\nAnother example of a function is the main function, the location where\nall code so far is written in. The layout of the main function will be\nviewed in more depth.\n\n\n\n\nCreating a Function\n\n\nSo far, every function used in this course were member functions already\nmade and placed in a library. Those functions are only for general use.\nIf needed, multiple functions can be created and specifically used in a\ncode file.\n\n\nA new function must first be declared and defined before it can be used.\nThe function declaration and the code that makes up the function are\nplaced outside and before the main function. A function cannot have\nanother function inside of it. The general outline for a function\ndeclaration will resemble the following:\n\nReturnType FunctionName(Parameters) {\n    // code to be performed\n    return returnValue;\n}\n\nWhen a function is called in the main function, the program will\nperform all code in the called function before it resumes where it\nleft off in the main function.\n\n\nThe return type will be the data type that the function will output. A\nfunction should always have a return statement. (return returnValue;)\nNotice how there is a return statement in the main function. (return 0;)\nThe return value will be the value the function will output. A function\ncannot output a data value that is a different type than the type listed\nat the beginning of the function. Any data type and container can be the\nreturn type of a function.\n\n\nBelow is a list of common return value types in C++\n\n\n\n\n\n\n\n\nReturn Type\nDescription\n\n\n\n\n\nvoid\n\nHas no return value\n\n\n\nint\n\nReturns an integer\n\n\n\nbool\n\nReturns a boolean value (true or false)\n\n\n\nchar\n\nReturns a character\n\n\n\n\nThe main purpose of a function is to output a return value. Once the\nprogram reaches a return statement, the program will immediately leave\nthe function with that return value. This is why all code must be\nplaced after the return 0; in the main function. Once the program\nreaches return 0;, it will immediately leave the main function with the\nvalue of 0. A function could have multiple return statements; however, a\nfunction will never return multiple values.\n\n\nJust because functions are made to return a data value, it does not mean\nthat they are unable to do anything else. Functions can have output and\ninput statements. Functions can even call other functions. If a\nfunction is called within another function, the program will first work\nthrough the function most recently called.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\nusing namespace std;\n\n// returns an integer, output3 is the function name\nint output3() {\n    // sqrt function is called, that program will call sqrt(9) and return 3\n    return sqrt(9); // program will go to line 13 with the value of 3\n    cout &lt;&lt; \"This message will never be outputted\";\n    // This output statement is placed after the return statement\n}\n\nint main() { // main function\n    cout &lt;&lt; output3() &lt;&lt; endl; // calls the output3 function (line 6)\n    cout &lt;&lt; \"End of Program.\"; // resumes executing code in main fcn\n    return 0;                  // return value of 0\n    cout &lt;&lt; \"This message will also never be outputted\";\n}\n\nOutput:\n\n\n\n3\nEnd of Program.\n\n\n\n\n\nParameters\n\n\nParameters are all the input values that go into a function. The return\nvalue in a function should depend on the parameters that are given. This\nmeans that different input values should give different return values.\nThe parameters that a function receives are defined in between the\nparentheses of the function declaration. A list of parameters for a\nfunction is called a parameter list. All parameters in a function will\nhave a data type and a parameter name. A parameter list is formatted as\nfollows:\n\nreturnType FunctionName(p1DataType p1Name, p2DataType p2Name ...) {}\n// the number of parameters in the function could continue\n\nParameters are separated by commas and are declared as if they were\nvariables. In fact, parameters can be used almost like variables.\nParameters must have both a data type as well as a parameter name. When\nusing parameters in a function, the data values of these parameters\ncannot be changed. (This will be covered further on in the chapter).\n\n\nParameters and return values are the only things that are passed between\nfunctions. All code in a function is completely independent from all\nother functions. That means that a function will always have its own\nindividual scope. This is important to note when regarding possible\nparameter or variable names.\n\n\nRemember how two variable names in the same scope cannot have the same\nvariable name. However, since each function has its own individual\nscope, a variable/parameter that is declared in a function can have the\nsame name as a variable located in another function. The location in\nmemory that the program will look at when it uses a variable depends on\nwhat scope the program is currently in.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n#include &lt;iostream&gt;\nusing namespace std;\n// notice how a and b are parameter/variable names in all 3 functions\n// but there will never be multiple a's and b's in the same scope\n\n// two integer parameters are given, in the scope, there are a and b\nint subtract(int a, int b) { // a = 10, b = 5\n    // evaluates a-b, then ends function and goes to line 21\n    return a - b; // 10 - 5 = 20\n}\n\n// another function. remember, in C++, scope is shown with braces and indents\nint add(int a, int b) { // a = 5, b = 10\n    // evaluates a+b, then function ends, program goes to line 21\n    return a + b; // 10 + 5 = 15\n}\n\nint main() { // main function, the program will always start with this\n    int a=5, b=10; // initializes two variables, a and b\n    // evaluates the expression before outputting\n    cout &lt;&lt; add(a,b) + subtract(b,a);\n    return 0; // returns 0 and program ends\n}\n\nOutput:\n\n\n\n20\n\n\n\nIn the code above, the program will start off in the main function.\nVariables a and b are created in the main function. On line 21,\nthe program will first call the add function with parameters a and\nb. The values of a and b are passed into the add function as\ninteger parameters. For clarification, the value of a in the main\nfunction will be stored in parameter a in the add function. Whenever\na and b are referred to in the add function, the program always\nrefers to the parameters, a and b. The add function will end up\nreturning 15.\n\n\nThe program will then move back to the main function where it then calls\nthe subtract function. Notice how variables, a and b, are\nflipped on line 21. This means that the value of b in the main\nfunction will be stored in parameter a in the subtract function.\nLikewise, the value of a in the main function will be stored in\nparameter b in the subtract function. When the subtract function is\ncalled, parameter a has a value of 10, and parameter b has a value\nof 5. Thus, the program evaluates 10 - 5 on line 9. The subtract\nfunction will return 5, and that value will add with 15 on line 21. In\nthe end, the program will output the value of 20.\n\n\nThe concept of functions can be very difficult to learn. That is why\nsome mid-chapter practice questions are added to this chapter to help\nreinforce your understanding of functions.\n\n\n\n\nWrite a program called maximum.cpp. Have the main function create a ten\nelement integer array, and allow users to input values in the array.\nAfter that, have the main function call another function called\nfindMax(). This function will take an array and return the largest\nvalue found in the array. Have the main function output the max value.\n\n\nModify maximum.cpp so that the code asking for user inputs is placed in\nanother function called getInputs(). getInputs() will ask for a value\nand return the user input. The main function will call getInputs() ten\nseparate times.\n\n\nAdd another function called findOccurences(). This function will take\na value and return how many times that value appears in the array.\nHave the main function ask for a value and then call findOccurences().\n\n\nJimbob made some more code and it looks so convoluted. Jimbob bets\nthat you would not be able to predict the outcome of his code. (which is\nsomething he should not brag about) Your job is to prove him wrong.\nPredict what Jimbob’s code will output without running it on\nCode::Blocks.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include &lt;iostream&gt;\nusing namespace std;\n\nint subtract(int b, int a) {\n    return a - b;\n}\n\nint add(int x, int y) {\n    return x + y;\n}\n\nint change(int a, int b, int c) {\n    int x = (a + b) - c;\n    cout &lt;&lt; x &lt;&lt; endl;\n    return subtract(x, a) + add(c, x);\n}\n\nint main() {\n    int x = 30, y = 20, z = 15;\n    cout &lt;&lt; change(y, z, x) + add(x, y);\n    return 0;\n}\n\n\n\n\n\n\nPassing by Value Versus Passing by Reference\n\n\nIn all previous examples of code, all the parameters in a function were\npassed by value. The values of all inputs were copied and given to\nthe parameters to be used. The values of the parameters cannot be\nchanged as parameters are not variables.\n\n\nFunctions are limited by the number of values that could be passed back\nand forth. Even though many values can be passed into a function as\nparameters, a function can only return one value (That’s the definition\nof a function). Consider a function that swaps the values of two input\nvariables. This function will end up needing to change two parameters,\nsomething that cannot be done when the parameters were passed by value.\nThis is why parameters can also pass by reference.\n\n\nPassing by reference is when parameters are given an address instead of\na value. This address refers to a specific location in memory that\nstores data. That way, a location in memory can be accessed and\nmanipulated across multiple functions. Parameters passed by reference\ncan be used just like a variable. To make a parameter pass by reference,\na &amp; is placed before the parameter name:\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n#include &lt;iostream&gt;\nusing namespace std;\n\n// void has no return value, but a and b are passed by reference\n// parameter 'a' acts as variable x, and parameter 'b' acts as variable y\nvoid fun(int &amp;a, int &amp;b) {\n    a=1; // the memory that 'a' refers to is changed to 1\n    b=2;\n    // outputs the values of a and b during the call\n    cout &lt;&lt; \"During Call: \" &lt;&lt; endl;\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n}\n\nint main() {\n    // 2 locations in memory are made and given data values\n    int x = 5, y = 7;\n    // outputs values of x and y before the call\n    cout &lt;&lt; \"Before Call: \" &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    // calls fun, the address of variable x is passed to the function\n    // the address of variable b is passed to the function\n    fun(x, y);\n    // outputs the values of x and y after the call\n    cout &lt;&lt; \"After Call: \" &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y;\n    return 0;\n}\n\nOutput:\n\n\n\nBefore Call:\n5 7\nDuring Call:\n1 2\nAfter Call:\n1 2\n\n\n\nIn the previous example, the address of variables x and y were passed by\nreference when the fun function was called. Any assignment to parameters\na and b will change the data values of variables x and y in the main\nfunction.\n\n\nUsually, a computer is quicker when passing by value as it would take\nless time to copy a value than use an address. Smaller data types such\nas integers will always be passed by value when there is no &amp; before\nthe parameter name. This makes an integer a scalar data type. It is\neasy for a computer to make a copy of a scalar data type because scalar\ndata types are often small in size.\n\n\nSome data types are larger in size and are not scalar data type. For\nexample, arrays are often so large that passing by value would take more\ntime than passing by reference. This is why containers such as arrays\nand vectors are automatically passed by reference.\n\n\nSome scalar data types include integers, characters, strings. booleans,\nand floats.\n\n\nSome non-scalar data types that automatically pass by reference include\narrays and vectors.\n\n\n\n\nRecursion\n\n\nIn previous examples that involve functions, there were moments where\nfunctions were called within another function. The program will finish\nexecuting the function most recently called before executing all other\nfunctions. Not only can functions call other functions, but a function\ncan call itself. The process of having a function call itself is called\nrecursion.\n\n\nA function would call itself the same way it could call any other\nfunction. Recursion can function similar to a loop because of how the\nsame code is repeated multiple times. Unlike actual loops, there is a\nlimit on how many times a function could recurse. A function cannot call\nitself forever because each function call takes up new memory.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n#include &lt;iostream&gt;\nusing namespace std;\n// This function will find terms in the fibonacci sequence. 1 1 2 3 5 8 13\n// term 1 and term 2 has the value of 1.\n// the next term in the sequence will always be the sum of the previous 2 terms\n// creates recursive function that returns a term in the fibonacci series\nint fib(int term) {     // term represents the term number in the series\n    if (term &lt; 3) {     // term 2 = 1, term 1 = 1\n        return 1;\n    }\n    else {              // all other terms are the sum of previous 2 terms\n        return fib(term - 1) + fib(term - 2);\n    }\n}\n\nint main() {\n    int n;\n    cout &lt;&lt; \"What term of the fibonacci series do you want to find?\" &lt;&lt; endl;\n    cin &gt;&gt; n; // gets term number\n    cout &lt;&lt; fib(n) &lt;&lt; \" is the term in the series.\"; // calls fibonacci\n    return 0;\n}\n\nSample Run:\n\n\n\nWhat term of the fibonacci series do you want to find?\n4\n3 is the term in the series\n\n\n\nThe recursive function above calls itself to find a term in the\nfibonacci sequence. Since all terms in the fibonacci sequence will be\nthe sum of the two previous terms, the function will call itself to find\nthe values of those two previous terms. Eventually, this recursive\nprocedure will continue until it adds the first and the second terms of\nthe fibonacci sequence.\n\n\nThis recursive process can be modelled using function notation in\nmathematics.\n\n\\[\n\\begin{aligned}\nfib(4)\n&= fib(4 - 1) + fib(4 - 2) \\\\\n&= fib(3) + fib(2) \\\\\n&= (fib(3 - 1) + fib(3 - 2)) + 1 \\\\\n&= (fib(2) + fib(1)) + 1 \\\\\n&= (1 + 1) + 1 \\\\\n&= (2) + 1 \\\\\n&= 3\n\\end{aligned}\n\\]\n\nGenerally, recursion would not be used to find a term in the fibonacci\nsequence. Recursion will be often used in applications such as graph\ntheory (advance course material). Do not excessively use recursion.\nIf it is possible to use a loop instead of recursion, use a loop!\n\n\n\n\nIn Summary\n\n\n\n\nA function is a set of code that outputs a single data value.\n\n\nA function will always have a name, a return type, and parameters\n\n\nThe main function is an example of a function\n\n\nCustom made functions are placed outside of the main function (And\ngenerally before it)\n\n\nA function can only return values of a specific data type\n\n\nParameters are input values that should affect the return value\n\n\nAll functions have their own individual scope\n\n\nParameters can either be passed by value or passed by reference\n\n\nScalar data values, such as integers, would normally be passed by value.\nThey can be passed by reference be putting a &amp; before the parameter\nname.\n\n\nArrays and vectors are automatically passed by reference.\n\n\nFunctions are able to call other functions\n\n\nRecursion is when a function calls itself repeatedly\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nCreate a file called swap.cpp. This file will have a function that will\nswap two integer values.\nNote: There are very few contest questions that require the usage of\nfunctions. Most of those contest questions are graph theory questions,\nwhich will be covered at a later time. That being said, below are\nexamples of questions that could use functions.\n\n\nM\n\n\n\n\n\n\n\nFurther Reading on Functions\n\n\nForward Declarations\n\nFor a program to be able to call another function, that function must be\ndeclared and defined before that call. If the function is placed\nsomewhere after the function call, the program will not know that the\nfunction exists. This is why libraries are included at the very\nbeginning of a C++ file. The program will have a list of functions it\nknows and expects to only call those functions. Thus, the program cannot\ntell whether a function does not exist, or is located further in the\nfile.\n\n\nForward declarations are used to notify the program that a specific\nfunction exists somewhere in the file. That way, the computer will\nrecognize the function when it finds a function call. When there is a\nforward declaration for a function, the program expects that the\nfunction will later be defined. That means that a forward declaration\nmust be paired with the actual function.\n\n\nA forward declaration in C++ resembles the following.\n\n\n\nreturnType functionName(p1Type p1Name, p2Type p2Name, ...);\n// All parameters and their type must be listed\n\n\n\nExample Code\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n#include &lt;iostream&gt;\nusing namespace std;\n// forward declaration, lets compiler know that write1 exists\nvoid write1(int n);\n// write0 alternates with write1. They both call each other a total of n times\nvoid write0(int n) {\n    if (n &gt; 0) {\n        cout &lt;&lt; 0;\n        // since the program knows that write1 exists, the compiler doesn't error out\n        write1(n - 1);  // goes back to write1\n    }\n}\nvoid write1(int n) {\n    if (n &gt; 0) {\n        cout &lt;&lt; 1;\n        write0(n - 1);  // calls write0\n    }\n}\nint main() {            // main function, program starts here\n    int n;\n    cin &gt;&gt; n;\n    write1(n);          // starts by calling write1\n\n    return 0;\n}\n\nSample Run:\n\n\n\n7\n1010101\n\n\n\nForwards Declarations are most often used when a program alternates\nbetween two functions\n\n\n\nGlobal Variables\n\nVariables can be declared outside of a function. These variables are\nknown as global variables. Variables that are declared inside of a\nfunction are known as local variables. Global variables have global\nscope. This means that they can be used throughout the entire C++ file.\nA file is able to have a global variable and a local variable with the\nsame name. However, whenever that variable is used in a function, the\nlocal variable will take priority.\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n#include &lt;iostream&gt;\nusing namespace std;\n// my global variables, can be used throughout the file\nint a = 3;\nint b = 4;\nint c = 5;\n\nint main() { // main function, program starts here\n    // local variable made and take precedence over the global variable\n    int a = 10;\n    int d = 20;        // local variable made\n    cout &lt;&lt; a &lt;&lt; endl; // outputs local variable\n    cout &lt;&lt; b &lt;&lt; endl; // no local variable exists, outputs global variable\n    cout &lt;&lt; d &lt;&lt; endl; // outputs local variable\n    cout &lt;&lt; a + b + c + d;\n\n    return 0;\n}\n\nOutput:\n\n\n\n10\n4\n20\n39\n\n\n\n\n\n\nNote\n\n\nDo not get in the habit of using global variables. In larger\nprojects, global variables become very dangerous as they can easily be\nmessed with. Using parameters over global variables is encouraged.\n\n\n\n\n\n\n" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"lessons-beginners-structures":{ url:"/lessons/beginners/structures",title:"Structures",subclub:"beginners",content:"\n\n\nGoal: To be able to create new data types and to be able to use them in code.\n\n\n\n\nIntroduction\n\n\nConsider having a C++ file that organizes and stores records of student\ninfo. Each student record will contain multiple fields of various data\ntypes. This data can be stored by having multiple vectors that store\neach field. This way of storing records is very messy.\n\n\nIf another student needs to be added to the list, every single vector\nhas to change in size. This will lead to many lines of code simply to\nreadjust the size of each vector.\n\n\nA structure is used in order to create an object, a new data type that\nis a collection of other data types. These other data types, called\nmember variables, will appear in every object. Those member variables\ncan be accessed through the object. In order to use this new data type,\nthis type must first be declared and defined.\n\n\nA struct declaration will resemble the following:\n\nstruct typeName {\n    member1Type member1Name;\n    member2Type member2Name;\n    // the number of members in the struct can continue\n};\n\nArrays and other containers can also be placed within a structure. A\ndata type of a member can start off as a certain value if that value is\nassigned within the struct declaration.\n\n\nOnce a struct has been declared, a new data type can be used across the\nC++ file. They are initialized just like any other variable.\n\n\n\ntypeName structName;\n\n\n\nIn order to access a specific member in a struct, a period is placed in\nbetween the struct name and the member name.\n\n\n\nstructName.memberName\n\n\n\nExample Code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct studentInfo {     // creates struct that stores student Info\n    string studentNum;  // each student will have a student number\n    string firstName;   // each student will have a first name\n    string lastName;    // ...\n    int grade;\n    int mark;\n    bool isPassing;\n};\n\nint main() {\n    studentInfo Thomas; // creates variable that is a studentInfo type\n    Thomas.studentNum = 404;              // accesses a member of studentInfo\n    Thomas.firstName = \"Thomas\";\n    Thomas.lastName = \"The Tank Engine\";  // Assigns Thomas a last name\n    Thomas.grade = 11;\n    Thomas.mark = 44;\n    Thomas.isPassing = false;\n\n    if (Thomas.isPassing) {               // Thomas.isPassing is a boolean value\n        cout &lt;&lt; Thomas.firstName &lt;&lt; \" \" &lt;&lt; Thomas.lastName &lt;&lt; \" is passing.\";\n    }\n    else {\n        cout &lt;&lt; Thomas.firstName &lt;&lt; \" \" &lt;&lt; Thomas.lastName &lt;&lt; \" is failing.\";\n    }\n    return 0;\n}\n\nOutput:\n\n\n\nThomas the Tank Engine is failing.\n\n\n\nArrays and vectors of structures can also be used. When accessing a\nmember variable in an array of structures, the index of the array should\nbe placed before the period. (arrayName[index].member).\n\n\nStructures are effective when organizing lists of records. Structures\nmust be defined within the C++ file it is in. Objects are not often used\nin contest questions, but are widely used in large scale projects and\ngames. The concept of objects can be delved further into a branch of\ncomputer science known as object oriented programming.\n\n\n\n\nIn Summary\n\n\n\n\nStructures are used to create new data types\n\n\nStructures must first be declared and defined before use\n\n\nAll variables in a structure are called member variables\n\n\nA period is used to access a member function in a struct\n\n\nArrays of structs can be made, and structs can include arrays\n\n\n\n\n\n\nPractice Questions\n\n\n\n\nPlatforme\n\n\nWoburn Workload\n\n\n\n\n" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"subclubs-beginners-index":{ url:"/subclubs/beginners/index",title:"beginners",subclub:"beginners",content:"beginners" },"resources-beginners-commonly-used-functions-in-cpp":{ url:"/resources/beginners/commonly-used-functions-in-cpp",title:"Commonly Used Functions in C++",subclub:"beginners",content:"\nMake sure to add the libraries that these functions belong in.\n\n\n\n\n\n\n\n\nFunction Name\nDescription\n\n\n\n\nstd::sort\nSorts an array/vector from least to greatest\n\n\nstd::reverse\nReverses an array/vector\n\n\nsqrt\nReturns the\nsquare root of a number\n\n\npow\nReturns the value\nof an exponent\n\n\nround\nRounds a floating number/double to the nearest integer\n\n\nceil\nRounds\nup a number\n\n\nfloor\nRounds down a number\n\n\nrand\nReturns a\nrandom integer\n\n\n" },"resources-beginners-debugging-common-errors":{ url:"/resources/beginners/debugging-common-errors",title:"Debugging Common Errors in C++",subclub:"beginners",content:"\n\n\nWhen trying to find errors in code, a debugger is often used. A debugger\nallows users to find problems in their code. If the code failed and\ncrashed when running or compiling, a message will be displayed on the\ndebugger showing where and what caused the code to crash.\n\n\nCode::Blocks is built with a debugger. It should naturally be located on\nthe bottom of the Code::Blocks window. There should be a bar with the\nname, *Logs &amp; Others* on it. If there is no debugger shown on\nCode::Blocks, press F2 or go to View &gt; Logs.\n\n\n\n\n\nFigure 1. An error being displayed in the Build messages tab. Here, we are told that the error is due to a missing semicolon on line 6.\n\n\nIn the debugger, the *Build messages* tab will display any messages\nwhen the computer is building/running a code file. If an error occurs,\nit will display a message and the line number the error is found in. In\ncase you have trouble understanding what the message means, below are a\nfew errors beginners to that would output a build message,\n\n\n\n\nError: redeclaration of '_'\n\n\n\n\nDid you initialize a variable twice? Two variables should not have the\nsame names.\n\n\n\n\n\n\nError: expected ';' before &#8230;&#8203;..\n\n\n\n\nYou simply missed a semicolon on the line right before the line that\nerrored.\n\n\n\n\n\n\nError: '__' was not declared in this scope&#8230;&#8203;&#8230;&#8203;.\n\n\n\n\nThis message is a little vague\n\n\nIs the word that is not declared supposed to be a variable?\n\n\n\nIs that variable initialized (Check spelling)?\n\n\nDid you initialize a variable inside a loop/if structure and tried to\naccess that variable outside of the loop?\n\n\n\n\n\nIs the word that is not declared supposed to be a command?\n\n\n\nDid you include both the standard library as well as the library the\ncommand is in.\n\n\n\nDoes your file have a “using namespace std;” and an include statement\nat the beginning of your file?\n\n\n\n\n\n\n\n\nIs the word that is not declared supposed to be a function?\n\n\n\nIs there a part in your code where a function is used before the\nfunction is declared?\n\n\n\nIf a function is placed after the main function, your code cannot call\nthe function inside the main function.\n\n\n\n\n\n\n\n\nIs the word that is not declared supposed to be text?\n\n\n\nPut quotation marks around them\n\n\n\n\n\n\n\n\n\nFatal error: &lt;name of library&gt;: No such file or directory; &#8230;&#8203;..\n\n\n\n\nMost likely, your file is saved as a C file and not a C++ file. In a C\nfile, many libraries such as string, iostream, and vectors, cannot be\nused.\n\n\nDid you spell the name of the library correctly?\n\n\n\n\n\n\nError: no match for 'operator&gt;&gt;'&#8230;&#8203;&#8230;&#8203;. or Error: no match for 'operator\\&lt;&lt;'&#8230;&#8203;..\n\n\n\n\nDid you mix up &gt;&gt; and &lt;&lt;? (&lt;&lt; are for cout statements and &gt;&gt; are for\ninput statements)\n\n\n\n\n\n\nError: invalid operands of types 'const char[ ]' and 'const char[ ]' to\n\n\nbinary&#8230;&#8203;&#8230;&#8203;.\n* Did you try to add two string literals? (text that are surrounded by\nquotation marks)\n* Avoid doing that altogether, but if you really need to add them, just\nomit the *+ sign.\n\n\n\n\nError: no match for 'operator\\&lt;'\n\n\n\n\nThis applies to every operator\n\n\nWhat happened was likely an error due to the order the computer performs\noperations. For example, &lt;&lt; is usually executed before a relational\noperator in an output statement\n\n\n\nJust add parenthesis and see if it works\n\n\n\n\n\n\n\n\n\nError: invalid operands of types '_' and '_' to 'binary operator%'&#8230;&#8203;&#8230;&#8203;..\n\n\n\n\nDid you try to perform a modulus operation when one of the values is not\nan integer/character?\n\n\n\nIf you are trying to mod a floating number, put (int) right in front\nof the variable to change the floating number into an integer. However,\nthis will cut off any decimals stored in the float.\nIf your code does not crash, but it is not outputting the values that\nyou expect it should output, check the following:\n\n\n\n\n\nDid you use any assignment variables(=) in an if/loop condition when\nyou should have used a relational operator (==)\n\n\n\nDo not mix = and == up\n\n\n\n\n\nWhen you initialize a counter variable for your for loop, did you give\nyour counter a value?\n\n\n\nIf not, then the value of the counter will be some garbage number.\n\n\n\n\n\nAre the variables that are sent into a function as parameters the\nintended variable type?\n\n\n\n\nThese are only a few errors that could come up when coding a C++ file.\nIf you are still left with an error with a build message, read through\nyour code once more to see if all of your code makes sense.\n\n\n" },"resources-beginners-faq":{ url:"/resources/beginners/faq",title:"Frequently Asked Questions",subclub:"beginners",content:"\nWill adding comments, having whitespace, or using longer variable names make my code run slower?\n\n\nNo. The program will not run slower. Before the computer runs a code\nfile, the compiler first works with the code. Its job is to take the\ncode and translate it into a set of instructions that a computer can\nread and follow. A compiler will skip through any whitespace and\ncomments in the code file and create an exe.file. Since, comments and\nwhitespace are omitted in a .exe file, it does not affect the\nperformance of the actual program. Technically, it will take a longer\ntime for the compiler to translate a code file with whitespace and\ncomments, but compilation time is not as important. Therefore, it is\nbest for a code file to be well documented with whitespace and comments.\n\n\n\n\nMy cursor is being weird and appears below the characters.\n\n\n\n\n\n\n\nPress kbd:[Insert] on your keyboard.\n\n\n\n\nHow do I change a floating number into an integer?\n\n\n\n\n\n\n\n(int) will take the data value of a variable and convert it into an\ninteger in order to be evaluated. It will not change the type of the\nvariable nor will it overwrite what is stored in the variable. When\nconverting from a floating number to an integer, the computer will\nignore all decimals in the floating number. (Ex: 4.9 will change to 4)\n\n\nIn general, putting (&lt;Datatype&gt;) in front of a variable will change\nthe type of a data value. This can be used when some functions only\naccept certain variable types as inputs.\n\n\n\n\nWhy does Code::Blocks not ask me to save my files?\n\n\nWhenever you build your code, your code file will be saved and an .exe\nfile will be created. Therefore, as long as you continuously build and\nrun your files, you would be saving them in the process. That being\nsaid, if you want to try something risky in your code file (such as\nreplacing a lot of lines), make a copy of your code file so that you\nwill always have a backup.\n\n\n\n\nHow do I add graphics in C++?\n\n\nGraphics for C++ is beyond the scope of the beginner course. Graphics\nin C++ is complicated. If you are very motivated, I would suggest\nlearning SDL, Here is an online tutorial on\nSDL!\n\n\n\n\nWhy is it int main() and not void main()?\n\n\n\n" },"resources-beginners-practice-problems-functions-questions":{ url:"/resources/beginners/practice-problems/functions-questions",title:"Functions Questions",subclub:"beginners",content:"\nPart I\n\n\n\n\n\n\n\n\nWrite a function, drawBox, that draws a box out of X’s with a\ngiven width and height. This function will have no return value.\n\n\nFor example, a 4 by 3 box will look like the following:\n\n\n\nXXXX\nX  X\nXXXX\n\n\n\nTable 1. Sample Call\n\n\n\n\n\n\nCall\nOutput\n\n\n\n\ndrawBox(4,5);\n\n\nXXXX\nX  X\nX  X\nX  X\nXXXX\n\n\n\n\ndrawBox(10,1);\n\n\nXXXXXXXXXX\n\n\n\n\ndrawBox(5,0);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a function that returns if a year is a leap year. This\nfunction will return a boolean value: true or false.\n\n\n\n\nAny year divisible by 4 is a leap year. However, if the year is\ndivisible by 100 and not divisible by 400, the year is not a leap\nyear.\n\n\n\n\nTable 2. Sample Call\n\n\n\n\n\n\nCall\nReturn Value\n\n\n\n\nisLeapYear(1992);\ntrue\n\n\nisLeapYear(1900);\nfalse\n\n\nisLeapYear(2000);\ntrue\n\n\n\n\n\n\n\nBelow is the formula used to convert a temperature from Celcius to\nFarenheit.\n\n\n\\[F = (9*C)/5 + 32\\]\n\n\n\nWrite a function that converts a temperature from Celcius to Farenheit.\nRound the final temperature to the nearest integer.\n\n\n\nWrite a function that finds the area of a circle with a given\nradius. The function will return a double with a precision of 2 decimal\nplaces.\n\n\n\n\n\n\nWrite a function that accepts three side lengths. It will return\nwhether the three sides can form a triangle.\n\n\nModify the function so that it returns whether the three side\nlengths form a right-angle triangle.\n\n\n\n\n\nWrite a function that accepts a positive integer and returns if the\nvalue is prime.\n\n\n\n\n\n\nWrite a function that accepts two strings, str1 and str2, as\narguments. Your function will search for the first occurrence of str2\nwithin str1 and return where it is found. If str2 is not found anywhere\nin str1, your function should return -1. You are basically coding the\nfind()\nfunction in the string library; do not use that function.\n\n\nModify your function so that the search is case insensitive.\n\n\nCreate your own\nreplace()\nfunction. This function takes two strings str1, str2 and str3. Anytime\nstr2 is found in str1, it is replaced with str3. Return the final\nstring. The search is case sensitive.\n\nTable 3. Sample Testcase\n\n\n\n\n\n\n\n\nstr1\nstr2\nstr3\nReturn Value\n\n\n\n\n\"Aayyy%lmao\"\n\"a\"\n\"Woah\"\n\"AWoahyyy%lmWoaho\"\n\n\n\n\n\n\n\n\n\n\n\n\nPart II\n\n\n\n\nWrite a function that passes two integer values, \\(a\\) and \\(b\\), by\nreference. Have the function swap the values of the two variables if \\(a\n&gt; b\\).\n\n\n\n\n\n\nWrite a function that takes a string as an argument and returns a\nstring that is in all caps.\n\n\nModify your function so that the string argument is changed\ndirectly. Change the return type of the function from string to void.\n\n\n\n\n\nWrite a function that sorts an integer array from least to greatest.\nDo not use sort(). Choose one of the following sorts:\n\n\n\nBubble Sort\n\n\nSelection Sort\n\n\nInsertion Sort\n\n\n\n\n\n\n\n\n\nRead the following piece of code and determine the following:\n\n\n\n\nThe output\n\n\nThe return values and parameters of each function call. Only use an IDE to check your answer.\n\n\n\n\nCode A\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint china(int a,int b){\n    cout &lt;&lt; a+b &lt;&lt; endl;\n    return a-b;\n}\n\nint germany(int a){\n    return a*2-1;\n}\n\nint canada(int x, int y, int z){\n    int a=germany(z)+germany(y);\n    return a+x;\n}\n\nint france(int y, int x){\n    int a=x-y;\n    return canada(x,y,a);\n}\n\nint main(){\n    int x=1,y=3,z=5;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; endl;\n    china(x,y);\n    cout &lt;&lt; china(z,y) &lt;&lt; endl;\n    cout &lt;&lt; canada(x,y,z) &lt;&lt; endl;\n    cout &lt;&lt; germany(france(x,z)) &lt;&lt; endl;\n    return 0;\n}\n\n\n\nCode B\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint kazakhstan(int b,int a){\n    return a-b;\n}\n\nint kyrgyzstan(int a,int b){\n    int c=a*b;\n    cout &lt;&lt; c &lt;&lt; \" \";\n    return c+b+a;\n}\n\nint azerbaijan(int&amp; a,int&amp; b){\n    int c=kazakhstan(b,a);\n    a=c*a;\n    b=c*b;\n    return c;\n}\n\nint main(){\n    int a=5,b=10;\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; kazakhstan(a,b) &lt;&lt; endl;\n    cout &lt;&lt; kyrgyzstan(kazakhstan(a,b),a+b) &lt;&lt; endl;\n    cout &lt;&lt; azerbaijan(b,a) &lt;&lt; endl;\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b;\n    return 0;\n}\n\n\n\nCode C\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint brazil(int&amp; a){\n    a=a*2-1;\n    return a-1;\n}\n\nint chile(int&amp; y,int&amp; x){\n    y+=3;\n    x+=2;\n    return y+x;\n}\n\nint peru(int&amp; x,int&amp; y){\n    x--;\n    chile(x,y);\n    return x*(x-y);\n}\n\nint main(){\n    int x=2,y=5;\n    brazil(y);\n    cout &lt;&lt; brazil(x)+y &lt;&lt; endl;\n    cout &lt;&lt; chile(x,y) &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    x=peru(y,x);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\nPart III\n\n\n\n\nWrite a recursive function that takes an integer n and returns n\nfactorial.\n\n\nWrite a recursive function that takes an integer n and returns the\nnth\ntriangular\nnumber. Do not use a loop or \\(\\dfrac{n (n + 1)}{2}\\).\n\n\nWrite a recursive function that takes a string argument and reverses\nthe string.\n\n\nWrite a recursive function that finds the nth term of the\nFibonacci\nSequence. This is also known as &#8220;the worst Fibonacci function&#8221; but do\nit anyways.\n\n\nWrite a recursive function that finds the GCF of two integers using\nthe\nEuclidian\nmethod.\n\n\nWrite a recursive function that returns a value from\nPascal&#8217;s Triangle\ngiven its row and column. The row and column numbers in Pascal’s\nTriangle start at 0.\n\n\n\n\nChallenge: Solve the J5 problem for\nthe 2015 CCC. This problem will use recursion.\n\n\n\n\nPART IV\n\n\n\n\n\n\n\n\nA formula for the area of a triangle\nis \\(A = \\frac{b*h}{2}\\) . Have a function named areaT return\nthe area of a triangle given its base and height. The parameters and\nreturn type will be integers.\n\n\n\n\n\n\nOne can also use Heron&#8217;s Formula to find the area of a triangle with\nside lengths a, b, and c.\n\n\n\n\\[A = \\sqrt{s(s - a)(s - b)(s - c)}\\]\n\n\n\nThe value of s is the semiperimeter of the triangle:\n\\(\\dfrac{a + b + c}{2}\\)\n\n\nCreate another function named areaT that takes three integer side\nlengths and returns the area using Heron&#8217;s Formula.\n\n\n\n\n\nCreate another function named areaT that takes the side length of an\nequilateral triangle and returns the area of that triangle.\n\n\n\n\n\n\n\n" },"resources-beginners-practice-problems-reinforcement-questions":{ url:"/resources/beginners/practice-problems/reinforcement-questions",title:"Reinforcement Questions",subclub:"beginners",content:"\n\n\nThese questions are here to test and reinforce your understanding of key\nconcepts so that you can ease into doing contest questions.\n\n\n\n\nLoops\n\n\n\n\n\n\n\n\nWrite a program that outputs a smiley face, :), an n number of\ntimes.\n\n\nInput: n (integer)\n\n\nOutput: \":)\" written n times\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n2\n:):)\n\n\n7\n:):):):):):):)\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that outputs the first 5 multiples of n.\n\n\nInput: n (integer)\n\n\nOutput: the first 5 multiples of n, starting with n\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n1\n1 2 3 4 5\n\n\n17\n17 34 51 68 85\n\n\n-8\n-8 -16 -24 -32 -40\n\n\n\n\n\n\n\nWrite a program that takes integers n and i. Your program will\nperform i calculations on n. The calculations done on n will\nalternate between the following:\n\n\n\n\\(n_{\\text{next}} = 2(n + 4)\\)\n\n\n\\(n_{\\text{next}} = \\dfrac{n + 2}{2}\\)\n\n\n\n\n\n\nThe program will output the final value of n.\n\n\nInput: n i\n\n\nOutput: resulting number after performing i calculations to n\n\n\nSample Input: \\(\\textcolor{red}{3}, 5\\)\n\n\nSample Output: 34\n\n\nExplanation:\n\n\n\n\\[\\begin{aligned}\n2(\\textcolor{red}{3}+4) &amp;= \\textcolor{blue}{14} \\\\\n\\frac{\\textcolor{blue}{14}+2}{2} &amp;= \\textcolor{orange}{8} \\\\\n2(\\textcolor{orange}{8}+4) &amp;= \\textcolor{green}{24} \\\\\n\\frac{\\textcolor{green}{24}+2}{2} &amp;= \\textcolor{purple}{13} \\\\\n2(\\textcolor{purple}{13}+4) &amp;= \\boxed{34}\n\\end{aligned}\\]\n\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n9 4\n19\n\n\n-12 9\n24\n\n\n35 16\n75\n\n\n1071 13789\n71090\n\n\n\n\n\n\n\nSuppose a number of dots were used to form an equilateral triangle.\nThe number of dots required to make the triangle increases as the number\nof rows increases. Notice how the number of dots in each row increases\nby one each time. \n\n\n\n\n\n\n\nGiven an n number of rows, determine the number of dots needed to make\nan equilateral triangle.\n\n\nInput: \\(n, n&gt;0\\)\n\n\nOutput: the number of dots required to make the triangle\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n6\n21\n\n\n12\n78\n\n\n256\n32896\n\n\n\n\n\n\n\n\n\n\n\nThe number of dots that form an equilateral triangle are called\ntriangular numbers.\nIn a sequence of all triangular numbers, t(n), t(n) would be the sum\nof all natural numbers up to and including n; that is, \\(t(n) = 1 + 2 + 3 + \\cdots + n\\)\n\n\nThere is a formula that calculates the \\(n^{th}\\) term in a sequence of\ntriangle numbers:\n\n\n\n\\[t(n) = \\frac{n(n + 1)}{2}\\]\n\n\n\nRewrite your program so that it now uses this formula to calculate the\nnumber of dots in an equilateral triangle. If you have originally used\nthis method, then rewrite your program so that it uses loops instead.\nUse the same test data as [4(a)].\n\n\n\n\n\n\n\n\n\n\n\n\nThe Fibonacci sequence is a list of numbers where each term is the\nsum of the previous two terms.\n\n\n\n\\[F_{n} = F_{n - 1} + F_{n - 2}\\]\n\n\n\nLet the zeroth and first term of the Fibonacci sequence be 0 and 1,\nrespectively. Write a program that outputs the \\(n^{th}\\) term of the\nfibonacci sequence.\n\n\nInput: \\(n\\)\n\n\nOutput: \\(n^{th}\\) term of the Fibonacci sequence\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n5\n5\n\n\n13\n233\n\n\n33\n3524578\n\n\n\n\nHint (Highlight to see): To find the \\(n^{th}\\) term in the sequence, you will start with the zeroth and first term and find all succeeding terms until you get to the \\(n^{th}\\) term.\n\n\n\n\n\nThe 3n+1 problem. The wcipeg\npage explains this nicely.\n\nHint (Highlight to see): The number of times 3n+1 and n/2 will be calculated is unknown. A while loop would suit this question.\n\n\n\n\n\n\n\nStrings\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes a word and outputs the reverse of a\nword.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nabbc\ncbba\n\n\nqwertyuiop\npoiuytrewq\n\n\n\n\n\n\n\n\n\n\n\nA palindrome is a string that can be read the same backward and\nforward. Write a program that takes a word and determines if it is a\npalindrome. If it is a palindrome, output YES. If it is not a\npalindrome, output NO.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nabcddcba\nYES\n\n\na\nYES\n\n\nqwertyqwerty\nNO\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes a word. Going through the index (\\(i\\)) of\nevery character, output the \\(i^{th}\\) character in the word \\(i+1\\) times.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nabc\nabbccc\n\n\nqwerty\nqwweeerrrrtttttyyyyyy\n\n\nbooo\nbooooooooo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes a word, then a character c. Your\nprogram will determine the number of times the character is found in the\nword.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nmississippi s\n4\n\n\nlolloooolooolasdoo o\n10\n\n\nkappa o\n0\n\n\n\n\n\n\n\n\n\n\n\nModify the program so that it will remove all instances where c\nappears in the word.\n\n\nYou may want to use\nstring::erase\nfrom the string library.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nmississippi s\nmiiippi\n\n\nlolloooolooolasdoo o\nlllllasd\n\n\nkappa o\nkappa\n\n\n\n\n\n\n\n\n\n\n\nModify your program again so that it accepts two characters this\ntime, c1 and c2. Each time c1 is found in the string, the\ncharacter is replaced with c2 instead. Each time c2 is found in the\nstring, the character is replaced with c1.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nmississippi i s\nmsiisiispps\n\n\nlolloooolooolasdoo o l\noloollllollloasdll\n\n\nkappa p p\nkappa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that will take a character. If the character is\nan uppercase letter, output \"U\". If the character is a lowercase letter,\noutput \"L\". If the character is not a letter, output \"N\".\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nS\nU\n\n\nt\nL\n\n\n@\nN\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that will take a word, and output the word in all\ncaps. I suggest you refer to an ASCII\ntable instead of 26 if statements.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nHello\nHELLO\n\n\nl33t\nL33T\n\n\nHoWiSLife??3\nHOWISLIFE??3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes an entire line of characters. You will\nneed to use the getline() function. After receiving an entire sentence,\noutput the sentence with all the words reversed. Assume no punctuation\nwill be given in the input.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\nThe cake is a lie\nlie a is cake The\n\n\nWhotypeswithspacesanyways\nWhotypeswithspacesanyways\n\n\nAll the words in the sentence must be reversed\nreversed be must\nsentence the in words the All\n\n\n\n\nHint (Highlight to see): All words are surrounded by spaces, and spaces are also characters. The length of each word in a sentence can be found be locating all the spaces in the sentence.\n\n\n\n\n\n\n\n\n\nHidden Palindrome is a good\ncontest question that you can find on WCIPEG. (Ex: In the string abcba,\nbcb is a palindrome surrounded by two a’s)\n\n\nHint 1 (Highlight to see): A palindrome is made up of a smaller palindrome surrounded by two of the same characters.\n\n\nHint 2 (Highlight to see): A way to check if a string is a palindrome is to start at the centre of the string and work outwards. For example, suppose i is the index of the centre of the string. For the string to be a palindrome, str[i-n] and str[i+n] must be the same. This idea should be used when finding hidden palindromes.\n\n\nThe solution to Hidden Palindrome can be found in the here.\n\n\n\n\n\n\n\n\n\nArrays\n\n\n\n\n\n\n\n\nWrite a program that takes in an n number of integer inputs. This\nprogram will store those integers in an array and determine the greatest\nnumber (h) and least number (l) of all the given integers.\n\n\nInput: \\(n\\); \\(k_1\\) to \\(k_n\\), the number of integers which follow \\(n\\) integers\n\n\nOutput: h l\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n7\n1 2 0 3 8 4 9\n9 0\n\n\n16\n11 2 93 82 78 54 1 82 -90 2 8 3 4 5 1 -3\n93 -90\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes an n number of integers. Store all the\nintegers into an array. Reorder the elements in the array so that all\nthe values in the array are reversed. Do not make a copy of the array\nwhile reversing. After reversing, output the \\(i^{th}\\) element of the\nreversed array. i will always be less than n.\n\n\nInput: \\(n\\); \\(k_1\\) to \\(k_n\\), the number of integers which follow \\(n\\) integers\n\\(i\\), \\(0 \\le i &lt; n\\)\n\n\nOutput: The value of the element in the reversed array at index i.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n10\n2 4 6 8 10 12 14 16 18 20\n6\n8\n\n\n5\n1 2 3 4 5\n1\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that takes n integers from 0 to 9. Determine\nthe number of times i appears in the array.\n\n\nInput: *n*, the number of integers which follow n integers, k0 to kn-1\n*i*, the integer to count\n\n\nOutput: The number of times i appeared as an input.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n6\n5 9 8 3 3 2 3\n3\n3\n\n\n20\n1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 0 1\n1\n15\n\n\n\n\n\n\n\n\n\n\n\nWrite a program that will continually accept integer inputs from 0-9\nuntil it receives a -1. Determine the number of times i appears in the\narray.\n\n\nInput: An unknown amount of integers from 0-9 , terminated by -1\n*i*, the integer to count\n\n\nOutput: The number of times i appeared as an input.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n1 6 3 2 4 1 1 2 3 5 1 5 3 7 2 4 3 7 1 3 2 -1\n1\n5\n\n\n7 4 9 8 4 5 2 6 7 4 3 4 -1\n4\n4\n\n\n\n\nHint (Highlight to see): Instead of having an array that stores all integer inputs, have an array that stores the number of times each number has been inputted so far.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn anagram is a rearrangement of the letters of a word/phrase to\nform another word/phrase. Write a program that will determines if two\nphrases are anagrams. You will need to use getline() for this question.\nIf the two phrases are anagrams, output &#8220;Y&#8221;. If the two phrases are not\nanagrams, output &#8220;N&#8221;.\n\n\nSample Run\n\n\n\n\n\n\nInput\nOutput\n\n\n\n\n\ndormitory\ndirty room\n\nY\n\n\n\neleven plus two\ntwelve plus one\n\nY\n\n\n\nabracadabra\ncabra darab\n\nN\n\n\n\n\nHint (Highlight to see): have a 26 element array that stores how many times each character appears in a string.\n\n\n\n\n\nRagaman is a variation of the problem above. This question can be\nfound on the WCIPEG website.\n\nHint (Highlight to see): Since the first word will never have any asterisks, if the second word has more of one character than the first word, the two words are not ragamans.\n\n\n\nEliminanagram is another problem that involves anagrams. This can\nalso be found on the WCIPEG site.\n\nHint (Highlight to see): For two words to be eliminanagrams, the total number of each character found in the two words must be even.\n\n\n\n\n\n\n\n\n" },"resources-beginners-syntax-references-list-of-operators":{ url:"/resources/beginners/syntax-references/list-of-operators",title:"List of Operators",subclub:"beginners",content:"\nArithmetic Operators\n\n\n\n\n\n\n\n\n\n\n\nName\nSyntax\nDescription\nExample\nOutput\n\n\n\n\nAddition\n+\nAdds two numbers together\n\n8 + 3\n\n\n11\n\n\n\nSubtraction\n-\nSubtracts two numbers together\n\n8 - 3\n\n\n5\n\n\n\nMultiplication\n*\nMultiplies two numbers together\n\n8 * 3\n\n\n24\n\n\n\nDivision\n/\n\nDivides the first number by second number.\n(Will drop the remainder when dividing an integer)\n\n\n8 / 3\n8.0 / 3\n\n\n2\n2.66667\n\n\n\nModulo\n%\nFinds the remainder when first number is divided by the\nsecond number. Only use Modulo on integer values.\n\n8 % 3\n\n\n2\n\n\n\nParenthesis\n()\n\nDictates the order in which operations are done.\nPrioritizes all operators inside parenthesis.\n\n\n2 * (8 - 3)\n\n\n10\n\n\n\n\n\n\n\nAssignment Operators\n\n\n\n\n\n\n\n\n\n\n\nName\nSyntax\nDescription\nExample\nEquivalent Operation\n\n\n\n\nAddition Assignment\n+=\nAdds the current data value with another\nx += 3\nx = x + 3\n\n\nSubtraction Assignment\n-=\nSubtracts the current data value with another\nx -= 4\nx = x - 4\n\n\nMultiplication Assignment\n*=\nMultiplies the current data value with another\nx *= 2\nx = x * 2\n\n\nDivision Assignment\n/=\nDivides the current data value with another\nx /= 5\nx = x / 5\n\n\nModulo Assignment\n%=\nTakes the remainder when the current data value is divided by another value\nx %= 3\nx = x % 3\n\n\nIncrement\n++\nIncreases the current data value by 1\nx++\nx += 1\n\n\nDecrement\n--\nDecreases the current data value by 1\nx--\nx -= 1\n\n\n\n\n\n\nRelational Operators\n\n\n\n\n\n\n\n\n\n\n\nName\nSymbol\nDescription\nExamples\nResult\n\n\n\n\nEqual to\n==\nChecks if two values are the same\n\n3 == 3\n4 == 3\n\n\ntrue\nfalse\n\n\n\nNot equal to\n!=\nChecks it two values are different\n\n3 != 4\n5 != 5\n\n\ntrue\nfalse\n\n\n\nGreater than\n&gt;\nChecks if the first value is greater than the second\n\n5 &gt; 0\n6 &gt; 6\n\n\ntrue\nfalse\n\n\n\nLess than\n\\&lt;\nChecks if the first value is less than the second\n\n3 &lt; 4\n5 &lt; 3\n\n\ntrue\nfalse\n\n\n\nGreater than or equal to\n&gt;=\nChecks if the first value is greater than or equal to the second value\n\n5 &gt;= 4\n4 &#8656; 4\n\n\ntrue\ntrue\n\n\n\nLess than or equal to\n&lt;=\nChecks it the first value is less than or equal to the second value\n\n3 &#8656; 3\n4 &#8656; 3\n\n\ntrue\nfalse\n\n\n\n\n\n\n\nLogical Operators\n\n\n\n\n\n\n\n\n\n\n\nName\nSymbol\nDescription\nExamples\nResult\n\n\n\n\nAND\n&amp;&amp;\nReturns true only if both sides are true\n\ntrue &amp;&amp; true\nfalse &amp;&amp; true\n\n\ntrue\nfalse\n\n\n\nOR\n||\nReturns true when either side is true\n\ntrue || false\n`false\n\n\n\n\nfalse`\ntrue\nfalse\nNOT\n\n!\n\n\nReturns true if false and returns false if true\n\n\n\n\n\n\n\nOther Operators\n\n\n\n\n\n\n\n\n\n\n\nName\nSymbol\nDescription\nExample\nResult\n\n\n\n\nXOR\n\\^\nThis is a bitwise operator. It can be used as a logical\noperator. It compares 2 boolean values and results true if only one of\nthem are true.\n\nfalse \\^ false\ntrue ^ false\nfalse ^ true\ntrue ^ true\n\n\nfalse\ntrue\ntrue\nfalse\n\n\n\n\n\n" },"resources-beginners-syntax-references-overview-of-cpp-syntax":{ url:"/resources/beginners/syntax-references/overview-of-cpp-syntax",title:"C++ Syntax",subclub:"beginners",content:"\nVariable declaration\n\nif ([condition])\n{\n    //code\n}\nelse if ([condition]); //terminates chain if true\nelse\n    //one statement will fall in an if, else,\n    //else if, or loop if there are no braces.\n\n\n\nTernary statement\n\n[conditional expression] ? [evaluates on true] : [evaluates on false]\n\n\n\nSwitch\n\nswitch ([basic type variable])\n{\ncase [constant]:\n    //code here\n    //multiple lines work\n    break;\ncase [constant]:\n    //code\ncase [constant]:\n    //without a break, the previous case falls into this\n    //case and will also do the code under this case.\ndefault:\n    //if before is satisfied, code here runs.\n    //previous two cases will fall here as they lack a break.\n}\n\n\n\nLoops\n\nwhile ([condition])\n{\n    //code here that will run when condition is true\n    //while (1) gives infinite loop\n    //strongly suggested that something changes in the condition here\n    if ([condition]) break; //exits the loop (works with all loops)\n    if ([condition]) continue; //skips all code below,\n                               //returning to the top\n                               //(works with all loops)\n    //code\n}\ndo\n{\n    //code here is done once, then loops if the below condition is true\n} while ([condition]); //you need the semicolon here\nfor ([initializer]; [condition]; [counter])\n{\n    //code\n    //special loop:\n    /* allows creation of counter variable which\n     * is checked by the condition and automatically\n     * updated by the counter at the end of an iteration.\n     * code order is as follows:\n     * initializer -&gt; condition -&gt; code -&gt; counter\n     *                      ^                |\n     *                      \\----------------/\n     */\n    //you can use a for(;;) for an infinite loop\n    //general usage is for (int i = 0; i &lt; times; i++)\n}\n\n\n\nFunctions\n\n[return type] [scope]::[function name]([params])\n{\n    // code\n    // all branches must terminate by returning a value that is of\n    // the return type\n    // return type of void does not require return\n    // return exits function immediately\n}\n// prototype - when referencing a function that's written later in the code,\n// first put up a prototype so that it won't tantrum with \"I haven't seen this // yet, it must be nonexistent!\"\n[return type] [function name]([param types]);\n\n\n\nStructs, classes, and namespaces\n\nstruct [struct name]\n{\n    // variables or function prototypes\n};\nclass [class name] : [inherits from]\n{\n    public:  // denotes that everything following allows public access\n    [class name](void);  // constructor, called on create\n    ~[class name](void); // destructor, called on delete\n    // variables or function prototypes\n};\nnamespace [nsp name]\n{\n    // variables or function prototypes\n};\n[return type] [struct/class/nsp name]::[function name]([params])\n{\n    // code\n    // prototypes not within scope require a special header\n    // for their functions using the namespace resolution operator.\n}\n\n\n\nEnums\n\nenum [enumeration name] : [type] // default type is int\n{\n    //list of terms. ex:\n    ENUM_1,                   // = 0     = 0\n    ENUM_2,                   // = 0 + 1 = 1\n    ENUM_3,                   // = 1 + 1 = 2\n    MUNE_0 = 0,               // = 0     = 0\n    MUNE_1,                   // = 0 + 1 = 1\n    MUNE_2,                   // = 1 + 1 = 2\n    MUNE_3 = MUNE_2 + ENUM_3, // = 2 + 2 = 4\n    MUNE_END                  // = 4 + 1 = 5\n    // enum terms are replaced by their values during compilation.\n    // allows for optimized readability - for example, directions can be\n    // enum'ed into integral values instead of a string\n};\n\n\n\nArrays\n\n[type] [name][[size]] = {[list]}; // declaration and initialization\n[name][[index]]                   // references the index of the array\n\n[type] [name][[size1]][[size2]][[size3]]; // you can have multi-dimensional\n                                          // arrays, like this one with three\n\n\n\nPointers\n\n[type] * [name] = &amp;[reference];       // decl. and init. of a reference pointer\n[type] * [name] = new [type][[size]]; //decl. and init. of an array pointer\n*[name]                               // dereference pointer\n[name] + [offset]                     // pointer arithmetic - \"point [offset] more [type]s later\"\n[name][[index]]                       // dereference of pointer array at index\n*([name] + [index])                   // above\n(*[name]).[property]                  // access property of dereferenced pointer\n[name]-&gt;[property]                    // shortcut for above\n&amp;[reference]                          // take address of reference - returns a pointer\n\n[type] ***** [name]; // pointers can be nested!\n                     // this has the potential to become a fifth-dimensional\n                     // jagged array.\n\n\n\nMain function\n\nint main (int argc, char* argv[])\n{\n    //begin code here\n    return 0;\n}\n\n" },"resources-beginners-syntax-references-variable-types-and-containers":{ url:"/resources/beginners/syntax-references/variable-types-and-containers",title:"Variable Types and Containers",subclub:"beginners",content:"\nVariable Types\n\n\n\n\n\n\n\n\n\n\nType\nSize\n(bytes)\nDescription\nRange\n\n\n\n\nint\n4\n\nUsed when the data are all integers\nEx: 1, 2, -8, 0, -350\n\n\n-2 147 483 648 to\n2 147 483 847\n\n\n\nunsigned int\n4\n\nUsed when the data are all positive integers and zero.\n\n\n0 to\n4 294 967 295\n\n\n\nfloat\n4\n\nIncludes all real numbers.\nEx: 1.0, 3.14, 1.2345\n\n\n\n\nchar\n1\n\nCharacters part of ASCII. Each character is stored as a numerical representation.\n\n\nEx: ‘a’,’b’,’@’\n\n\nIrrelevant if only used for ASCII\n\n\n\nboolean\n1\n\nStores either true (1) or false (0)\n\n\n\n\nlong long\n8\n\nUsed when the data are very large integers that go beyond the range of an integer type\n\n\n-9 quintillion to\n9 quintillion\n\n\n\nunsigned long long\n8\n\nUsed when the data are all very large integers that never go below 0\n\n\n0 to 18 quintillion\n\n\n\nshort\n2\n\nSmaller range of integers, uses less memory\n\n\n-32 768 to\n32 767\n\n\n\nunsigned short\n2\n\nUsed when the data are all small positive integers and zero\n\n\n0 to 65 535\n\n\n\ndouble\n8\n\nUsed when more memory is needed for a float\n\n\n\n\n\n\n\n\nC++ containers\n\n\n\n\n\n\n\n\n\nName\nLibrary\nDescription\n\n\n\n\nArrays\n\n\n\n\nVector\n&lt;vector&gt;\n\n\n\nStack\n&lt;stack&gt;\n\n\n\nQueue\n&lt;queue&gt;\n\n\n\nPair\n&lt;utility&gt;\n\n\n\nMap\n&lt;map&gt;\n\n\n\n\n\n" },"resources-beginners-terms-and-definitions":{ url:"/resources/beginners/terms-and-definitions",title:"Common Terms and Definitions",subclub:"beginners",content:"\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nArray\n\nA container that stores a series of data values of the same\ntype\n\n\n\nBoolean Values\n\nData that can be one of two values, true (1) or false\n(0)\n\n\n\nCompiler\n\nA program that takes a code file and translates it into a\nset of instructions that a computer could understand and follow.\n\n\n\nConsole\n\nAn interface that can receive input values and display output\nvalues.\n\n\n\nContainer\n\nA collection of variables stored under a given identifier.\n\n\n\nControl Flow\n\nThe order in which a computer executes code.\n\n\n\nDebugger\n\nA program that is used to help test and debug code files.\n\n\n\nDocumentation\n\nStructure of a code file. This includes whitespacing\nand commenting.\n\n\n\nElement\n\nA variable inside of a container.\n\n\n\nFunction\n\nA command for a computer. Typically, functions will include\ninputs and result one output.\n\n\n\nGlobal Variables\n\nVariables that are initialized outside of a\nfunction, they are able to be used throughout the entire C++ file.\n\n\n\nHard Coding\n\nGiving values to variables directly in the code file.\n\n\n\nIdentifier\n\nA name that a computer uses to refer to a specific\nlocation in memory.\n\n\n\nIndex\n\nA data value that indicates which variable is being referred to\nin a container\n\n\n\nIntegrated development Environment (IDE)\n\nA program that is designed\nfor programmers to write code.\n\n\n\nLibrary\n\nA file that contains a list of functions that a computer\nshould know.\n\n\n\nLocal Variables\n\nVariables that are initialized in a function. These\nvariables can only be used in the function they are declared in.\n\n\n\nOperator\n\na symbol that manipulates or compares data values (Ex:\n+, =, &gt;, !)\n\n\n\nParameter\n\nData Values that are sent to a function when that function\nis called\n\n\n\nMemory\n\nA part in a computer that is used to store/retrieve data\n\n\n\nRecursion\n\nThe process of having a function call itself\n\n\n\nScalar Data Values\n\nData values that take up little memory. They are\nnormally passed to a function by value.\n\n\n\nScope\n\nA range/area in a code file that limits where variables can be\nused in.\n\n\n\nSpaghetti\n\nA type of code that is convoluted and unnecessarily hard to read.\nIt is difficult to edit spaghetti code as it is prone to bugs.\nTherefore, creating spaghetti code is frowned upon.\n\n\n\nString\n\nA container that stores a series of characters\n\n\n\nString Literal\n\nA sequence of characters enclosed by quotation marks.\n(Ex: \"hello\")\n\n\n\nSyntax\n\nGuidelines on how specific functions can be used.\n\n\n\nVariable\n\nAn identifier used in a code file that refers to a specific location in memory.\n\n\n\nWhitespace\n\nAny part of the code that is left blank. This includes\nspaces, indents, and empty lines.\n\n\n\n" }, },posts:{ "announcements-2017-10-csec-orientation-this-friday-oct-6":{ url:"/announcements/2017/10/csec-orientation-this-friday-oct-6/",title:"CSEC Orientation This Friday, Oct. 6!",content:"Hello everyone!\n\nOur first meeting is scheduled to be this Friday, October 6 after school in room 206, which is next to room 205, which is across the hallway between 208 and 204 in the business/tech hall.\n\nWe’ll be explaining more about the club and about Computer Science, we’ll iron out signup discrepancies, and if logistics allow the Coding subclubs will be splitting up to work on getting set up for the year.\n\nWe strongly suggest you attend this meeting, though if you are unable to, we will send out a recap email with any important information attached.\n\nSee you Friday!\n\nCSEC Exec Team\n" },"announcements-2017-09-welcome-to-the-new-csec-site":{ url:"/announcements/2017/09/welcome-to-the-new-csec-site/",title:"Welcome to the new CSEC website!",content:"Welcome to Markville CSEC’s brand new website!\nWe’re still moving in and getting accustomed to our new setting, and this site is not yet totally complete, so please bear with any issues you see.\nIf, in particular, you have any suggestions and bugs to report, please click the “?” at the bottom-right of your screen.\n\nWhat’s ready and what’s not\n\nSubclubs\n\nAs of publication date, there are only two visible subclubs: Beginners’ and Advanced.\nWe will be adding the Artificial Intelligence and Nuances of Programming subclubs at a later date, pending their existence.\n\nIf you’re wondering where the Web Development subclub went, it has unfortunately been discontinued for the 2017-2018 school year.\n\nLessons\n\nWe have ported all of the Beginners’ lessons, and are in the process of porting Advanced lessons.\nThis process should be complete by the end of September.\n\nResources\n\nThe Beginners’ resources have all been ported; however, kinks exist to be ironed out.\nAs well, you may notice that the guides are empty; we’re currently working on writing them. Stay tuned!\n\nMiscellaneous\n\nThere’s still a few bits left to polish; in particular, search doesn’t work yet, which is something we’re actively trying to fix.\nAs well, we will be updating the hero backgrounds over the next few weeks with new images and visualizations from a select group of students.\nCheck back frequently to see what we’re up to!\n\nContact us\n\n\n  Email us!\n  Check us out on GitHub!\n  Give feedback (or better yet, report a bug)\n\n" }, } };
</script>


  </main>
  <!-- footer -->
  <footer class="site-footer">
  <div class="container">
    <div class="row">
      <div class="two columns">
        <svg xmlns="http://www.w3.org/2000/svg" width="116" height="40">
          <rect width="116" height="40" mask="url(#m)" fill="currentColor"></rect>
        </svg>
        <p class="yo">
          <a href="https://github.com/mss-csec/mss-csec.github.io" title="Our GitHub"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill="currentColor" fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38C13.71 14.53 16 11.53 16 8c0-4.42-3.58-8-8-8z"/></svg>
</a>
          <a href="#" title="Our email" onclick="event.preventDefault();APP.revealEmail()"><?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 16"><path fill="currentColor" fill-rule="evenodd" d="M0 4v8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1zm13 0L7 9 1 4h12zM1 5.5l4 3-4 3v-6zM2 12l3.5-3L7 10.5 8.5 9l3.5 3H2zm11-.5l-4-3 4-3v6z"/></svg>
</a>
        </p>
        <p class="version">Build <a href="https://github.com/mss-csec/mss-csec.github.io/commit/dd7c8e329c821d46ef6b2ba1e1d203c228542159" target="_blank">dd7c8e3</a></p>
      </div>
      <div class="two columns">
        <h5>This is CSEC</h5>
        <p><a href="/about">About us</a></p>
        <p><a href="/privacy">Privacy notice</a></p>
        <p><a href="https://docs.google.com/forms/d/e/1FAIpQLSc4Jd-UXs7ZK6XK7SF48zwxlyF84g1a3ER4w_WhONGqxkaeSQ/viewform" onclick="event.preventDefault();FEEDBACKDisplayModal()">Give feedback</a></p>
      </div>
      <div class="two columns">
        <h5>Announcements</h5>
        
        <p><a href="/announcements/2017/10/csec-orientation-this-friday-oct-6/">CSEC Orientation This Friday, Oct. 6!</a></p>
        
        <p><a href="/announcements/2017/09/welcome-to-the-new-csec-site/">Welcome to the new CSEC website!</a></p>
        
        <p><a href="/posts">All posts&hellip;</a></p>
      </div>
      <!--
      <div class="two columns">
        <h5>Markville SS</h5>
        <p><a href="http://markville.ss.yrdsb.ca/" target="_blank" class="link-extern">School website</a></p>
        <p><a href="http://schools.yrdsb.ca/markville.ss/teacher/computers/computers.htm" target="_blank" class="link-extern">MSS Comp Sci</a></p>
        <p><a href="https://en.wikipedia.org/wiki/Markville_Secondary_School" target="_blank" class="link-extern">Wikipedia</a></p>
      </div>
    -->
      <div class="three offset-by-three columns">
        <h5>Disclaimer</h5>
        <p>The Computer Science and Education Club is a student-run organization in Markville Secondary School. All views and opinions presented here are CSEC's own, and do not represent those of the York Region District School Board or Markville Secondary School in any way.</p>
      </div>
    </div>
  </div>
</footer>

</body>
</html>
